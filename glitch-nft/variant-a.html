<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>VΞCTOR DRΞΛM</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; font-family: monospace; display: flex; align-items: center; justify-content: center; min-height: 100vh; }
    canvas { display: block; width: 1000px; height: 1000px; max-width: 95vmin; max-height: 95vmin; image-rendering: pixelated; }
    #ui {
      position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 12px; align-items: center; z-index: 100;
      background: rgba(0,0,0,0.9); padding: 10px 20px; border: 1px solid #f0f3;
    }
    #ui button { background: transparent; border: 1px solid #0ff; color: #0ff; padding: 6px 14px; font: 10px monospace; cursor: pointer; }
    #ui button:hover { background: #0ff1; }
    .info { color: #f0f8; font-size: 9px; }
    #hud { position: fixed; top: 15px; right: 15px; font-size: 9px; text-align: right; z-index: 100; color: #fff4; }
    #hud .up { color: #0ff; } #hud .down { color: #f0f; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud"><div>BTC <span id="btc" class="up">---</span></div><div>ETH <span id="eth" class="up">---</span></div></div>
<div id="ui"><div class="info">#<span id="seed-num">0</span></div><button id="randomize">GENERATE</button><button id="save">CAPTURE</button></div>

<script>
let M = { sent: 0, vol: 0.3 };
async function fetchM() {
  try {
    const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd&include_24hr_change=true');
    const d = await r.json();
    M.btc = d.bitcoin.usd_24h_change || 0; M.eth = d.ethereum.usd_24h_change || 0;
    M.sent = Math.tanh((M.btc + M.eth) / 8);
    M.vol = Math.min(1, (Math.abs(M.btc) + Math.abs(M.eth)) / 12);
    document.getElementById('btc').textContent = (M.btc >= 0 ? '+' : '') + M.btc.toFixed(1) + '%';
    document.getElementById('btc').className = M.btc >= 0 ? 'up' : 'down';
    document.getElementById('eth').textContent = (M.eth >= 0 ? '+' : '') + M.eth.toFixed(1) + '%';
    document.getElementById('eth').className = M.eth >= 0 ? 'up' : 'down';
  } catch(e) {}
}
fetchM(); setInterval(fetchM, 45000);

let seed = parseInt(new URLSearchParams(window.location.search).get('seed')) || Math.floor(Math.random() * 100000);
function mulberry32(a) { return function() { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

let R, C;
function gen(s) {
  seed = s; R = mulberry32(seed);
  
  // === STYLE ARCHETYPE (each seed picks 1 of 11 distinct styles) ===
  const styleRoll = R();
  let style;
  if (styleRoll < 0.09) style = 'synthwave';
  else if (styleRoll < 0.18) style = 'databend';
  else if (styleRoll < 0.27) style = 'corrupt';
  else if (styleRoll < 0.36) style = 'liquid';
  else if (styleRoll < 0.45) style = 'minimal';
  else if (styleRoll < 0.54) style = 'retro';
  else if (styleRoll < 0.63) style = 'neon';
  else if (styleRoll < 0.72) style = 'geometric';
  else if (styleRoll < 0.81) style = 'void';
  else if (styleRoll < 0.91) style = 'isometric';
  else style = 'chaos';
  
  // === SUB-STYLE VARIANT (A, B, or C within each style) ===
  const subStyle = R() < 0.33 ? 'A' : (R() < 0.66 ? 'B' : 'C');
  
  // === COMPOSITION ZONE (where elements concentrate) ===
  const zoneRoll = R();
  let zone;
  if (zoneRoll < 0.15) zone = 'top';
  else if (zoneRoll < 0.30) zone = 'bottom';
  else if (zoneRoll < 0.45) zone = 'left';
  else if (zoneRoll < 0.60) zone = 'right';
  else if (zoneRoll < 0.75) zone = 'center';
  else if (zoneRoll < 0.88) zone = 'edges';
  else zone = 'scattered';
  
  // === BACKGROUND TYPE ===
  const bgRoll = R();
  let bgType;
  if (bgRoll < 0.4) bgType = 'solid';
  else if (bgRoll < 0.7) bgType = 'gradient';
  else bgType = 'textured';
  
  // === EXPANDED COLOR PALETTES (16 options) ===
  const pals = [
    [330, 185, 0],     // pink/cyan/red
    [320, 190, 30],    // magenta/teal/orange
    [340, 175, 200],   // coral/aqua/purple
    [310, 195, 15],    // fuchsia/mint/gold
    [350, 170, 280],   // rose/turquoise/violet
    [20, 180, 300],    // orange/cyan/magenta
    [280, 200, 40],    // purple/teal/yellow
    [345, 160, 220],   // red/blue/lavender
    [190, 330, 60],    // cyan/pink/yellow
    [260, 30, 170],    // blue/orange/magenta
    [15, 195, 315],    // red-orange/teal/purple
    [300, 180, 90],    // magenta/cyan/lime
    [45, 200, 330],    // gold/cyan/violet
    [270, 90, 180],    // purple/yellow-green/magenta
    [0, 210, 60],      // red/cyan-blue/yellow
    [225, 45, 135],    // blue/orange/pink
  ];
  const pal = pals[Math.floor(R() * pals.length)];
  
  // === COLOR INTENSITY (varies dramatically) ===
  // 50% chance of extra saturation boost
  const satBoost = R() < 0.5 ? 0.15 : 0.0;
  const colorIntensity = 0.6 + R() * 0.4 + satBoost; // 0.6 to 1.15
  const colorShift = (R() - 0.5) * 80;    // -40 to +40 hue shift
  
  // === BRIGHTNESS/CONTRAST ===
  const brightness = 0.7 + R() * 0.6;     // 0.7 to 1.3
  
  // === BASE CONFIG (all zeroed - styles add their own) ===
  C = {
    style: style,
    subStyle: subStyle,
    zone: zone,
    bgType: bgType,
    brightness: brightness,
    // Colors with more variation
    h1: pal[0] + colorShift + (R()-.5)*70,
    h2: pal[1] + colorShift + (R()-.5)*70,
    h3: pal[2] + colorShift + (R()-.5)*80,
    colorIntensity: colorIntensity,
    // All effects start at 0
    clusters: 0, density: 0, pixelSize: 3, scatter: 0,
    glitchAmt: 0, rectGlitch: 0, diagStreak: 0,
    spireCount: 0, spireIntensity: 0, gridIntensity: 0, horizonGlow: 0, bandGlitch: 0,
    spireSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    dripIntensity: 0, rippleAmt: 0, auroraAmt: 0, grainAmt: 0,
    chromaAmt: 0, hSortAmt: 0, marbleAmt: 0, mirrorAmt: 0, dataBlocks: 0,
    blockSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    crtAmt: 0, vhsAmt: 0, posterize: 0, geoShapes: 0, edgeGlow: 0, noiseWarp: 0, invertAmt: 0,
    shapeSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    isoCubes: 0, isoSize: 0.15, isoRgbSplit: 0,
    cubeSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    primSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    // Composition offsets based on zone
    zoneOffsetX: 0, zoneOffsetY: 0,
    bgGradientAngle: R() * 6.28,
    bgNoiseScale: 5 + R() * 20
  };
  
  // === ZONE OFFSETS ===
  if (zone === 'top') { C.zoneOffsetY = 0.3 + R() * 0.2; }
  else if (zone === 'bottom') { C.zoneOffsetY = -0.3 - R() * 0.2; }
  else if (zone === 'left') { C.zoneOffsetX = -0.3 - R() * 0.2; }
  else if (zone === 'right') { C.zoneOffsetX = 0.3 + R() * 0.2; }
  else if (zone === 'edges') { C.zoneOffsetX = (R() < 0.5 ? -1 : 1) * (0.4 + R() * 0.2); }
  
  // === STYLE-SPECIFIC OVERRIDES (with A/B/C sub-variants) ===
  if (style === 'synthwave') {
    C.grainAmt = 0.02 + R() * 0.04;
    if (subStyle === 'A') { // Heavy spires, minimal grid
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.spireCount = 5 + Math.floor(R() * 3);
      C.spireIntensity = 0.5 + R() * 0.4;
      C.gridIntensity = R() * 0.1;
      C.horizonGlow = 0.15 + R() * 0.2;
    } else if (subStyle === 'B') { // Grid focused, few spires
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.spireCount = Math.floor(R() * 2);
      C.spireIntensity = 0.2 + R() * 0.2;
      C.gridIntensity = 0.35 + R() * 0.35;
      C.horizonGlow = 0.2 + R() * 0.25;
      C.bandGlitch = 0.1 + R() * 0.15;
    } else { // Balanced with mirror
      C.pixelSize = 2 + Math.floor(R() * 3);
      C.spireCount = 3 + Math.floor(R() * 3);
      C.spireIntensity = 0.35 + R() * 0.3;
      C.gridIntensity = 0.15 + R() * 0.2;
      C.horizonGlow = 0.1 + R() * 0.15;
      C.mirrorAmt = 0.8 + R() * 0.2;
    }
  }
  else if (style === 'databend') {
    C.grainAmt = 0.06 + R() * 0.1;
    if (subStyle === 'A') { // Drip heavy
      C.pixelSize = 2;
      C.dripIntensity = 0.5 + R() * 0.4;
      C.auroraAmt = 0.1 + R() * 0.15;
      C.hSortAmt = 0.1 + R() * 0.15;
    } else if (subStyle === 'B') { // Aurora focused
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.dripIntensity = 0.1 + R() * 0.2;
      C.auroraAmt = 0.4 + R() * 0.4;
      C.hSortAmt = 0.2 + R() * 0.25;
      C.scatter = 0.15 + R() * 0.2;
    } else { // Sort-heavy with ripple
      C.pixelSize = 3;
      C.dripIntensity = 0.15 + R() * 0.2;
      C.hSortAmt = 0.4 + R() * 0.4;
      C.rippleAmt = 0.25 + R() * 0.3;
    }
  }
  else if (style === 'corrupt') {
    C.grainAmt = 0.04 + R() * 0.08;
    if (subStyle === 'A') { // Block heavy
      C.pixelSize = 4 + Math.floor(R() * 3);
      C.dataBlocks = 4 + Math.floor(R() * 4);
      C.glitchAmt = 0.3 + R() * 0.3;
      C.chromaAmt = 0.15 + R() * 0.2;
      C.clusters = 1;
      C.density = 0.2 + R() * 0.2;
    } else if (subStyle === 'B') { // Chromatic chaos
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.dataBlocks = 1 + Math.floor(R() * 2);
      C.chromaAmt = 0.4 + R() * 0.4;
      C.glitchAmt = 0.5 + R() * 0.4;
      C.rectGlitch = 0.4 + R() * 0.35;
      C.clusters = 2;
      C.density = 0.35 + R() * 0.3;
    } else { // Band glitch focus
      C.pixelSize = 3 + Math.floor(R() * 3);
      C.bandGlitch = 0.4 + R() * 0.4;
      C.rectGlitch = 0.35 + R() * 0.35;
      C.dataBlocks = 2 + Math.floor(R() * 2);
      C.scatter = 0.4 + R() * 0.3;
      C.clusters = 2;
      C.density = 0.3 + R() * 0.3;
    }
  }
  else if (style === 'liquid') {
    C.grainAmt = 0.02 + R() * 0.04;
    if (subStyle === 'A') { // Heavy marble
      C.pixelSize = 2;
      C.marbleAmt = 0.4 + R() * 0.35;
      C.rippleAmt = 0.1 + R() * 0.15;
      C.clusters = 1;
      C.density = 0.15 + R() * 0.2;
    } else if (subStyle === 'B') { // Ripple focused
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.marbleAmt = 0.15 + R() * 0.2;
      C.rippleAmt = 0.4 + R() * 0.35;
      C.auroraAmt = 0.2 + R() * 0.25;
      C.clusters = 2;
      C.density = 0.2 + R() * 0.25;
    } else { // Mirror liquid
      C.pixelSize = 2;
      C.marbleAmt = 0.3 + R() * 0.25;
      C.rippleAmt = 0.25 + R() * 0.25;
      C.dripIntensity = 0.2 + R() * 0.25;
      C.mirrorAmt = 0.9 + R() * 0.1;
    }
  }
  else if (style === 'minimal') {
    C.grainAmt = 0.08 + R() * 0.12;
    if (subStyle === 'A') { // Ultra sparse
      C.pixelSize = 6 + Math.floor(R() * 4);
      C.clusters = 1;
      C.density = 0.08 + R() * 0.12;
      C.scatter = 0.6 + R() * 0.3;
    } else if (subStyle === 'B') { // Streak minimal
      C.pixelSize = 4 + Math.floor(R() * 3);
      C.clusters = 1;
      C.density = 0.12 + R() * 0.15;
      C.diagStreak = 0.25 + R() * 0.3;
      C.scatter = 0.3 + R() * 0.3;
    } else { // Minimal with subtle grid
      C.pixelSize = 5 + Math.floor(R() * 3);
      C.clusters = 1;
      C.density = 0.1 + R() * 0.15;
      C.gridIntensity = 0.05 + R() * 0.08;
      C.spireCount = 1;
      C.spireIntensity = 0.1 + R() * 0.1;
    }
  }
  else if (style === 'retro') {
    if (subStyle === 'A') { // Heavy CRT
      C.pixelSize = 4 + Math.floor(R() * 3);
      C.crtAmt = 0.6 + R() * 0.35;
      C.vhsAmt = 0.1 + R() * 0.15;
      C.posterize = 6 + Math.floor(R() * 4);
      C.grainAmt = 0.06 + R() * 0.08;
      C.clusters = 2;
      C.density = 0.3 + R() * 0.25;
    } else if (subStyle === 'B') { // VHS focused
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.crtAmt = 0.2 + R() * 0.2;
      C.vhsAmt = 0.4 + R() * 0.4;
      C.posterize = 4 + Math.floor(R() * 3);
      C.grainAmt = 0.1 + R() * 0.12;
      C.bandGlitch = 0.2 + R() * 0.2;
      C.clusters = 1;
      C.density = 0.2 + R() * 0.2;
    } else { // Posterized
      C.pixelSize = 5 + Math.floor(R() * 4);
      C.crtAmt = 0.25 + R() * 0.25;
      C.posterize = 3 + Math.floor(R() * 2);
      C.grainAmt = 0.12 + R() * 0.1;
      C.chromaAmt = 0.15 + R() * 0.2;
      C.clusters = 2;
      C.density = 0.25 + R() * 0.3;
    }
  }
  else if (style === 'neon') {
    C.grainAmt = 0.01 + R() * 0.03;
    if (subStyle === 'A') { // Glow heavy
      C.pixelSize = 2;
      C.edgeGlow = 0.6 + R() * 0.35;
      C.clusters = 3 + Math.floor(R() * 2);
      C.density = 0.4 + R() * 0.35;
      C.diagStreak = 0.2 + R() * 0.2;
    } else if (subStyle === 'B') { // Streak neon
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.edgeGlow = 0.3 + R() * 0.25;
      C.diagStreak = 0.5 + R() * 0.4;
      C.clusters = 2;
      C.density = 0.3 + R() * 0.3;
      C.chromaAmt = 0.2 + R() * 0.2;
    } else { // Neon grid
      C.pixelSize = 2;
      C.edgeGlow = 0.4 + R() * 0.3;
      C.gridIntensity = 0.2 + R() * 0.25;
      C.clusters = 2;
      C.density = 0.35 + R() * 0.3;
      C.mirrorAmt = 0.7 + R() * 0.3;
    }
  }
  else if (style === 'geometric') {
    C.grainAmt = 0.01 + R() * 0.03;
    if (subStyle === 'A') { // Shape heavy
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.geoShapes = 5 + Math.floor(R() * 4);
      C.clusters = 0;
      C.density = 0.05;
      C.mirrorAmt = R() < 0.5 ? 0.9 : 0;
    } else if (subStyle === 'B') { // Iso + shapes
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.geoShapes = 2 + Math.floor(R() * 3);
      C.isoCubes = 3 + Math.floor(R() * 3);
      C.isoSize = 0.1 + R() * 0.1;
      C.isoRgbSplit = 0.01 + R() * 0.015;
    } else { // Blocks + shapes
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.geoShapes = 3 + Math.floor(R() * 3);
      C.dataBlocks = 2 + Math.floor(R() * 3);
      C.rectGlitch = 0.25 + R() * 0.25;
      C.edgeGlow = 0.2 + R() * 0.2;
    }
  }
  else if (style === 'isometric') {
    C.grainAmt = 0.015 + R() * 0.025;
    if (subStyle === 'A') { // Dense cubes
      C.pixelSize = 2;
      C.isoCubes = 6 + Math.floor(R() * 3);
      C.isoSize = 0.08 + R() * 0.08;
      C.isoRgbSplit = 0.02 + R() * 0.025;
    } else if (subStyle === 'B') { // Large cubes + grid
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.isoCubes = 3 + Math.floor(R() * 2);
      C.isoSize = 0.15 + R() * 0.15;
      C.isoRgbSplit = 0.015 + R() * 0.02;
      C.gridIntensity = 0.1 + R() * 0.15;
    } else { // Cubes + geo shapes
      C.pixelSize = 2;
      C.isoCubes = 4 + Math.floor(R() * 3);
      C.isoSize = 0.1 + R() * 0.1;
      C.isoRgbSplit = 0.012 + R() * 0.018;
      C.geoShapes = 2 + Math.floor(R() * 2);
      C.mirrorAmt = R() < 0.4 ? 0.95 : 0;
    }
  }
  else if (style === 'void') {
    C.grainAmt = 0.1 + R() * 0.12;
    if (subStyle === 'A') { // Dark scatter
      C.pixelSize = 4 + Math.floor(R() * 3);
      C.clusters = 1;
      C.density = 0.06 + R() * 0.08;
      C.scatter = 0.7 + R() * 0.25;
      C.noiseWarp = 0.2 + R() * 0.2;
    } else if (subStyle === 'B') { // Inverted void
      C.pixelSize = 3 + Math.floor(R() * 3);
      C.clusters = 1;
      C.density = 0.08 + R() * 0.1;
      C.invertAmt = 0.6 + R() * 0.4;
      C.scatter = 0.5 + R() * 0.3;
      C.noiseWarp = 0.1 + R() * 0.15;
    } else { // Spire void
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.spireCount = 2 + Math.floor(R() * 2);
      C.spireIntensity = 0.15 + R() * 0.15;
      C.horizonGlow = 0.08 + R() * 0.1;
      C.scatter = 0.4 + R() * 0.3;
      C.auroraAmt = 0.1 + R() * 0.15;
    }
  }
  else if (style === 'chaos') {
    // Chaos picks random elements but not all at once
    C.pixelSize = 2 + Math.floor(R() * 5);
    C.grainAmt = 0.04 + R() * 0.08;
    C.clusters = 1 + Math.floor(R() * 3);
    C.density = 0.2 + R() * 0.4;
    // Pick 3-4 random effects to activate
    const effects = ['spires','grid','drips','aurora','blocks','chromatic','marble','crt','glow','iso','shapes'];
    const shuffled = effects.sort(() => R() - 0.5);
    const picked = shuffled.slice(0, 3 + Math.floor(R() * 2));
    picked.forEach(e => {
      if (e === 'spires') { C.spireCount = 2 + Math.floor(R() * 3); C.spireIntensity = 0.2 + R() * 0.25; }
      if (e === 'grid') { C.gridIntensity = 0.15 + R() * 0.25; }
      if (e === 'drips') { C.dripIntensity = 0.25 + R() * 0.3; }
      if (e === 'aurora') { C.auroraAmt = 0.2 + R() * 0.25; }
      if (e === 'blocks') { C.dataBlocks = 2 + Math.floor(R() * 3); }
      if (e === 'chromatic') { C.chromaAmt = 0.25 + R() * 0.3; }
      if (e === 'marble') { C.marbleAmt = 0.2 + R() * 0.25; }
      if (e === 'crt') { C.crtAmt = 0.3 + R() * 0.3; }
      if (e === 'glow') { C.edgeGlow = 0.3 + R() * 0.3; }
      if (e === 'iso') { C.isoCubes = 2 + Math.floor(R() * 3); C.isoSize = 0.1 + R() * 0.1; }
      if (e === 'shapes') { C.geoShapes = 2 + Math.floor(R() * 3); }
    });
    if (R() < 0.2) C.mirrorAmt = 0.7 + R() * 0.3;
  }
  
  // === WILD CARD MUTATIONS (3-5% chance each, stacking) ===
  if (R() < 0.04) C.mirrorAmt = 1.0;
  if (R() < 0.04) C.chromaAmt += 0.35;
  if (R() < 0.04) C.pixelSize = 8 + Math.floor(R() * 5);
  if (R() < 0.04) C.grainAmt += 0.18;
  if (R() < 0.04) C.dataBlocks += 4;
  if (R() < 0.04) C.crtAmt += 0.45;
  if (R() < 0.04) C.invertAmt = 0.85 + R() * 0.15;
  if (R() < 0.04) C.edgeGlow += 0.45;
  if (R() < 0.04) C.vhsAmt += 0.35;
  if (R() < 0.04) C.posterize = 2 + Math.floor(R() * 2);
  if (R() < 0.03) { C.density = 0.85; C.scatter = 0.7; }
  if (R() < 0.03) { C.clusters = 5; C.spireCount = 7; }
  if (R() < 0.03) C.marbleAmt += 0.35;
  if (R() < 0.03) C.noiseWarp += 0.3;
  if (R() < 0.02) { C.isoCubes = 8; C.isoRgbSplit = 0.035; }
  if (R() < 0.02) { C.geoShapes = 8; }
  if (R() < 0.02) { C.h1 += 180; } // hue flip
  if (R() < 0.02) { C.colorIntensity = 0.3; } // desaturated
  if (R() < 0.02) { C.brightness = 1.4; } // blown out
  if (R() < 0.02) { C.brightness = 0.5; } // dark
  
  // Display style info
  document.getElementById('seed-num').textContent = seed + ' [' + style + '-' + subStyle + '] ' + zone;
}
gen(seed);

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl');

const VS = `attribute vec2 p;varying vec2 uv;void main(){uv=p*.5+.5;gl_Position=vec4(p,0,1);}`;

const FS = `
precision highp float;
varying vec2 uv;
uniform float t;
uniform vec2 res;
uniform float h1,h2,h3,clusters,density,pixelSize,scatter,glitchAmt,rectGlitch,diagStreak;
uniform float sent,vol;
uniform float spireCount,spireIntensity,gridIntensity,horizonGlow,bandGlitch;
uniform float spireSeeds[6];
uniform float dripIntensity,rippleAmt,auroraAmt,grainAmt;
uniform float chromaAmt,hSortAmt,marbleAmt,mirrorAmt,dataBlocks;
uniform float blockSeeds[5];
uniform float crtAmt,vhsAmt,posterize,geoShapes,edgeGlow,noiseWarp,invertAmt;
uniform float shapeSeeds[6];
uniform float isoCubes,isoSize,isoRgbSplit;
uniform float cubeSeeds[8];
uniform float primSeeds[5];
uniform float zoneOffsetX,zoneOffsetY,bgGradientAngle,bgNoiseScale;
uniform float colorIntensity,brightness;
uniform int bgType; // 0=solid, 1=gradient, 2=textured

#define PI 3.14159265
#define TAU 6.28318531

float H(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
float H3(vec3 p){return fract(sin(dot(p,vec3(127.1,311.7,74.7)))*43758.5453);}

vec3 hsv(float h,float s,float v){
  vec3 c=clamp(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);
  return v*mix(vec3(1),c,s);
}

void main(){
  // Pixelate UV
  float pxSize = pixelSize / res.x;
  vec2 puv = floor(uv / pxSize) * pxSize;
  vec2 pxCoord = floor(uv * res.x / pixelSize);
  
  vec2 p = (puv - 0.5) * 2.0;
  
  // === MIRROR EFFECT (applied early to UV) ===
  if(mirrorAmt > 0.1) {
    p.x = mix(p.x, abs(p.x), mirrorAmt);
  }
  
  // === LIQUID MARBLE FLOW (UV displacement) ===
  if(marbleAmt > 0.02) {
    float flowX = sin(p.y * 4.0 + t * 0.2) * cos(p.x * 3.0 + t * 0.15);
    float flowY = cos(p.x * 5.0 - t * 0.25) * sin(p.y * 2.5 + t * 0.1);
    vec2 marble = vec2(flowX, flowY) * marbleAmt * 0.15;
    p += marble;
  }
  
  // === NOISE WARP (organic displacement) ===
  if(noiseWarp > 0.02) {
    float warpX = sin(p.x * 8.0 + p.y * 4.0 + t * 0.3) * cos(p.y * 6.0 + t * 0.2);
    float warpY = cos(p.x * 5.0 + p.y * 7.0 - t * 0.25) * sin(p.x * 4.0 + t * 0.15);
    p += vec2(warpX, warpY) * noiseWarp * 0.12;
  }
  
  // === VHS WOBBLE (horizontal distortion) ===
  if(vhsAmt > 0.02) {
    float wobble = sin(p.y * 50.0 + t * 8.0) * sin(p.y * 3.0 + t * 0.5);
    p.x += wobble * vhsAmt * 0.04;
    // VHS tracking lines
    float tracking = step(0.97, fract(p.y * 8.0 + t * 0.3));
    p.x += tracking * (H(vec2(floor(p.y * 8.0), t)) - 0.5) * 0.2 * vhsAmt;
  }
  
  // === DYNAMIC BACKGROUND ===
  vec3 col = vec3(0.01, 0.005, 0.015);
  if(bgType == 1) {
    // Gradient background
    vec2 gradDir = vec2(cos(bgGradientAngle), sin(bgGradientAngle));
    float gradT = dot(puv - 0.5, gradDir) + 0.5;
    vec3 gradCol1 = hsv(h1 / 360.0, 0.3 * colorIntensity, 0.08);
    vec3 gradCol2 = hsv(h2 / 360.0, 0.25 * colorIntensity, 0.04);
    col = mix(gradCol1, gradCol2, gradT);
  } else if(bgType == 2) {
    // Textured background
    float noise = H(floor(puv * bgNoiseScale));
    col = vec3(0.01 + noise * 0.03, 0.005 + noise * 0.02, 0.015 + noise * 0.025);
  }
  
  // Apply zone offset to working position
  vec2 zp = p - vec2(zoneOffsetX, zoneOffsetY);
  
  // === SYNTHWAVE HORIZON GRADIENT (subtle, seed-controlled) ===
  if(horizonGlow > 0.02) {
    float horizonY = -0.3 + 0.1 * sin(t * 0.05);
    if(p.y < horizonY + 0.4) {
      float gradT = smoothstep(horizonY - 0.2, horizonY + 0.4, p.y);
      vec3 deepTeal = vec3(0.02, 0.04, 0.06);
      vec3 hGlow = hsv((h1 + 20.0) / 360.0, 0.6, horizonGlow);
      col = mix(hGlow, deepTeal, gradT);
    }
  }
  
  // Colors with intensity variation
  vec3 c1 = hsv((h1 + sent * 20.0) / 360.0, 0.95 * colorIntensity, 1.0);
  vec3 c2 = hsv((h2 + sent * 15.0) / 360.0, 0.9 * colorIntensity, 1.0);
  vec3 c3 = hsv((h3 + sent * 25.0) / 360.0, 0.85 * colorIntensity, 0.9);
  vec3 c4 = hsv((h1 + 180.0) / 360.0, 0.8 * colorIntensity, 0.85);
  
  // === SYNTHWAVE CRYSTAL SPIRES (seed-controlled) ===
  float spireVis = spireIntensity + 0.1 * sent; // market influences
  for(int i = 0; i < 6; i++) {
    if(float(i) >= spireCount) break;
    float fi = float(i);
    float ss = spireSeeds[i]; // unique seed per spire
    float spireX = (H(vec2(ss, 77.0)) - 0.5) * 2.2;
    float spireWidth = 0.03 + H(vec2(ss, 78.0)) * 0.06;
    float spireHeight = 0.3 + H(vec2(ss, 79.0)) * 0.5;
    float spireBase = -0.9;
    
    // Jagged crystal shape
    float inSpire = step(abs(p.x - spireX), spireWidth * (1.0 - (p.y - spireBase) / spireHeight));
    inSpire *= step(spireBase, p.y) * step(p.y, spireBase + spireHeight);
    
    if(inSpire > 0.5) {
      // Crystal facet shading
      float facet = floor((p.y - spireBase) / 0.08);
      float shade = 0.4 + 0.3 * H(vec2(ss, facet));
      vec3 spireCol = mix(c1, c2, H(vec2(ss, 80.0))) * shade * spireVis;
      
      // Wireframe edge highlight
      float edgeDist = abs(abs(p.x - spireX) - spireWidth * (1.0 - (p.y - spireBase) / spireHeight));
      if(edgeDist < pxSize * 2.0) {
        spireCol = c1 * 0.8;
      }
      col = max(col, spireCol);
    }
  }
  
  // === HORIZON WIREFRAME GRID (seed-controlled) ===
  if(gridIntensity > 0.02) {
    float gridY = -0.5;
    if(p.y < gridY && p.y > -1.0) {
      float perspective = 1.0 / (gridY - p.y + 0.1);
      float gridX = p.x * perspective;
      float gridZ = perspective * 0.5;
      
      // Grid lines
      float lineX = smoothstep(0.02, 0.0, abs(fract(gridX * 0.8 + t * 0.1) - 0.5) - 0.45);
      float lineZ = smoothstep(0.02, 0.0, abs(fract(gridZ * 2.0 + t * 0.3) - 0.5) - 0.45);
      float grid = max(lineX, lineZ) * (gridIntensity + 0.1 * vol);
      
      vec3 gridCol = mix(c1, c2, 0.5) * grid * (1.0 - (gridY - p.y) * 0.8);
      col = max(col, gridCol);
    }
  }
  
  // === GLITCH DISTORTION ZONES ===
  for(int c = 0; c < 5; c++) {
    if(float(c) >= clusters) break;
    float ps = primSeeds[c];
    
    // Zone center - randomized position
    vec2 center = vec2(
      H(vec2(ps, 1.0)) * 2.0 - 1.0,
      H(vec2(ps, 2.0)) * 2.0 - 1.0
    ) * 0.7;
    
    float dist = length(p - center);
    float zoneSize = 0.15 + H(vec2(ps, 3.0)) * 0.25;
    
    // Inside the distortion zone
    if(dist < zoneSize) {
      float zoneFade = 1.0 - dist / zoneSize;
      float zoneType = H(vec2(ps, 4.0));
      
      // Pick zone color
      vec3 zoneCol;
      float colSel = H(vec2(ps, 5.0));
      if(colSel < 0.25) zoneCol = c1;
      else if(colSel < 0.5) zoneCol = c2;
      else if(colSel < 0.75) zoneCol = c3;
      else zoneCol = c4;
      
      if(zoneType < 0.33) {
        // Horizontal scan distortion - shifts pixels horizontally
        float scanY = floor((p.y - center.y + zoneSize) / (pxSize * 3.0));
        float shift = (H(vec2(scanY, ps)) - 0.5) * 0.15 * zoneFade;
        float scanRand = H(vec2(pxCoord.x + shift * 100.0, scanY + ps));
        if(scanRand < 0.6 * zoneFade) {
          col = mix(col, zoneCol, 0.7 * zoneFade);
        }
      } else if(zoneType < 0.66) {
        // Pixel scatter - random pixels within zone
        float pxRand = H(pxCoord + ps);
        if(pxRand < 0.4 * zoneFade * zoneFade) {
          float bright = 0.6 + H(pxCoord + ps + 100.0) * 0.5;
          col = zoneCol * bright;
        }
      } else {
        // Color bleed - soft color wash
        col = mix(col, zoneCol * 0.7, zoneFade * 0.5);
        // Add some pixel noise on top
        float noiseRand = H(pxCoord + ps * 10.0 + floor(t * 3.0));
        if(noiseRand < 0.15 * zoneFade) {
          col = zoneCol;
        }
      }
    }
  }
  
  // === SCATTERED NOISE PIXELS ===
  float noiseRand = H(pxCoord + floor(t * 2.0));
  float noiseRand2 = H(pxCoord.yx + floor(t * 1.5));
  if(noiseRand < scatter * 0.15) {
    float colSel = H(pxCoord + 500.0);
    if(colSel < 0.5) col = c1 * (0.5 + noiseRand2);
    else col = c2 * (0.5 + noiseRand2);
  }
  
  // === RECTANGULAR GLITCH OUTLINES ===
  for(int i = 0; i < 6; i++) {
    float fi = float(i);
    // Use hash with shapeSeeds for per-generation randomization
    float rs = shapeSeeds[i] + fi * 100.0;
    float rectSeed = H(vec2(fi + fract(rs * 0.01), floor(t * 0.5)));
    if(rectSeed > 1.0 - rectGlitch) {
      // Randomized movement direction and speed per block
      float moveAngle = fract(rs * 0.00123) * 6.28;
      float moveSpeed = 0.05 + fract(rs * 0.00234) * 0.2;
      float moveAmt = fract(rs * 0.00345) * 0.5;
      
      vec2 rectPos = vec2(
        (fract(rs * 0.001) - 0.5) * 2.0 + sin(t * moveSpeed + fi) * moveAmt * cos(moveAngle),
        (fract(rs * 0.002) - 0.5) * 2.0 + sin(t * moveSpeed + fi) * moveAmt * sin(moveAngle)
      );
      
      // Much more varied sizes (tiny to large)
      vec2 rectSize = vec2(
        0.02 + fract(rs * 0.003) * 0.35,
        0.02 + fract(rs * 0.004) * 0.25
      );
      
      // Random rotation per block
      float rectRot = fract(rs * 0.005) * 0.5 - 0.25;
      vec2 rp = p - rectPos;
      float cr = cos(rectRot); float sr = sin(rectRot);
      rp = vec2(rp.x * cr - rp.y * sr, rp.x * sr + rp.y * cr);
      
      // Rectangle outline check
      vec2 d = abs(rp) - rectSize;
      float outline = max(d.x, d.y);
      float innerOutline = max(d.x + pxSize * 2.0, d.y + pxSize * 2.0);
      
      if(outline < 0.0 && innerOutline > 0.0) {
        float rectColSel = fract(rs * 0.006);
        if(rectColSel < 0.33) col = c1;
        else if(rectColSel < 0.66) col = c2;
        else col = c3;
      }
    }
  }
  
  // === SYNTHWAVE BAND GLITCHES (chunky horizontal tears, seed-controlled) ===
  if(bandGlitch > 0.05) {
    for(int b = 0; b < 4; b++) {
      float fb = float(b);
      float bandSeed = H(vec2(fb + 20.0, floor(t * 0.2)));
      if(bandSeed > 1.0 - bandGlitch - vol * 0.1) {
        float bandY = (H(vec2(fb, 30.0)) - 0.5) * 1.8;
        float bandH = 0.02 + H(vec2(fb, 31.0)) * 0.06;
        
        if(abs(p.y - bandY) < bandH) {
          float bandShift = (H(vec2(fb, 32.0)) - 0.5) * 0.3;
          float bandRand = H(pxCoord + vec2(bandShift * 100.0, fb));
          
          // Chunky color bands like the reference
          if(bandRand < 0.5) {
            col = mix(col, c1 * 0.9, 0.7);
          } else if(bandRand < 0.7) {
            col = mix(col, c3 * 0.8, 0.5);
          }
        }
      }
    }
  }
  
  // === HORIZONTAL GLITCH DISPLACEMENT ===
  float hGlitchLine = step(0.92 - vol * 0.05, H(vec2(pxCoord.y, floor(t * 4.0))));
  if(hGlitchLine > 0.5) {
    float shiftAmt = (H(vec2(pxCoord.y + 1.0, floor(t * 4.0))) - 0.5) * 20.0;
    vec2 shiftCoord = pxCoord + vec2(shiftAmt, 0.0);
    float shiftRand = H(shiftCoord + floor(t * 2.0));
    if(shiftRand < density * 0.8) {
      col = mix(c1, c2, H(shiftCoord + 100.0));
    }
  }
  
  // === BLOCK DISPLACEMENT ===
  vec2 blockCoord = floor(uv * 8.0);
  float blockGlitch = step(0.88 - vol * 0.08, H(blockCoord + floor(t * 1.5)));
  if(blockGlitch > 0.5) {
    vec2 blockShift = (vec2(H(blockCoord + t), H(blockCoord.yx + t)) - 0.5) * 0.1;
    vec2 newPxCoord = floor((uv + blockShift) * res.x / pixelSize);
    float bRand = H(newPxCoord + 200.0);
    if(bRand < 0.5) {
      col = mix(col, c1, 0.7);
    } else if(bRand < 0.7) {
      col = mix(col, c3, 0.6);
    }
  }
  
  // === RGB CHANNEL SPLIT ===
  float rgbSplit = glitchAmt * 0.02 * (1.0 + vol);
  vec2 rCoord = floor((uv + vec2(rgbSplit, 0.0)) * res.x / pixelSize);
  vec2 bCoord = floor((uv - vec2(rgbSplit, 0.0)) * res.x / pixelSize);
  
  float rShift = H(rCoord + floor(t * 2.0));
  float bShift = H(bCoord + floor(t * 2.0));
  
  if(rShift < density * 0.5 && col.r < 0.1) col.r += c1.r * 0.6;
  if(bShift < density * 0.5 && col.b < 0.1) col.b += c2.b * 0.5;
  
  // === SCANLINE GLITCH ===
  float scanGlitch = step(0.95, sin(puv.y * 300.0 + t * 50.0));
  col = mix(col, col.gbr, scanGlitch * 0.5);
  
  // === PIXEL DROPOUT ===
  float dropout = step(0.97, H(pxCoord + floor(t * 8.0)));
  if(dropout > 0.5 && length(col) > 0.1) {
    col = vec3(0.0);
  }
  
  // === FRAME CORRUPTION BLOCKS ===
  vec2 corruptBlock = floor(uv * 5.0);
  float corrupt = step(0.93 - vol * 0.05, H(corruptBlock + floor(t * 0.8)));
  if(corrupt > 0.5) {
    col = col.brg;
  }
  
  // === STATIC NOISE BURST ===
  float staticBurst = step(0.96, H(vec2(floor(t * 6.0), 0.0)));
  if(staticBurst > 0.5) {
    float staticPx = H(pxCoord + t * 100.0);
    if(staticPx > 0.7) col = vec3(staticPx * 0.5);
  }
  
  // === AURORA COLOR CURTAINS (vertical color bleed) ===
  if(auroraAmt > 0.02) {
    for(int a = 0; a < 5; a++) {
      float fa = float(a);
      float curtainX = (H(vec2(fa, 200.0)) - 0.5) * 2.5;
      float curtainW = 0.1 + H(vec2(fa, 201.0)) * 0.3;
      float curtainDist = abs(p.x - curtainX);
      
      if(curtainDist < curtainW) {
        float curtainFade = 1.0 - curtainDist / curtainW;
        curtainFade *= curtainFade;
        
        // Vertical color gradient
        float gradPos = p.y * 0.5 + 0.5 + sin(t * 0.1 + fa) * 0.2;
        vec3 curtainCol = mix(c1, c2, gradPos);
        curtainCol = mix(curtainCol, c3, sin(gradPos * PI) * 0.5);
        
        col = mix(col, curtainCol, curtainFade * auroraAmt * 0.6);
      }
    }
  }
  
  // === VERTICAL DRIP STREAKS (pixel sort style) ===
  if(dripIntensity > 0.02) {
    float dripX = floor(puv.x * 60.0);
    float dripSeed = H(vec2(dripX, 300.0));
    
    if(dripSeed < dripIntensity) {
      float dripStart = (H(vec2(dripX, 301.0)) - 0.3) * 1.5;
      float dripLen = 0.2 + H(vec2(dripX, 302.0)) * 0.6;
      float dripSpeed = 0.1 + H(vec2(dripX, 303.0)) * 0.2;
      
      float dripY = mod(dripStart - t * dripSpeed, 2.5) - 0.5;
      
      if(p.y < dripY && p.y > dripY - dripLen) {
        float dripFade = (dripY - p.y) / dripLen;
        vec3 dripCol = mix(c1, c2, H(vec2(dripX, 304.0)));
        dripCol *= 0.7 + 0.3 * dripFade;
        col = mix(col, dripCol, (1.0 - dripFade) * 0.7);
      }
    }
  }
  
  // === RIPPLE WAVE TEXTURE ===
  if(rippleAmt > 0.02) {
    float ripple = sin(p.x * 25.0 + p.y * 8.0 + t * 0.5) * 
                   sin(p.y * 15.0 - p.x * 5.0 + t * 0.3);
    ripple = ripple * 0.5 + 0.5;
    
    // Fingerprint-like whorls
    float whorl = sin(length(p - vec2(0.3, 0.2)) * 30.0 - t * 0.2) * 
                  sin(atan(p.y - 0.2, p.x - 0.3) * 8.0 + t * 0.1);
    whorl = whorl * 0.5 + 0.5;
    
    float pattern = mix(ripple, whorl, 0.3);
    vec3 rippleCol = mix(c2, c3, pattern);
    col = mix(col, rippleCol, pattern * rippleAmt * 0.4);
  }
  
  // === HORIZONTAL PIXEL SORT STREAKS ===
  if(hSortAmt > 0.02) {
    float sortY = floor(puv.y * 40.0);
    float sortSeed = H(vec2(sortY, 400.0));
    
    if(sortSeed < hSortAmt) {
      float sortDir = H(vec2(sortY, 401.0)) < 0.5 ? 1.0 : -1.0;
      float sortSpeed = 0.2 + H(vec2(sortY, 402.0)) * 0.4;
      float sortPhase = fract(t * sortSpeed * sortDir + H(vec2(sortY, 403.0)));
      
      // Stretch colors horizontally
      float stretchX = sortPhase * 2.0 - 1.0;
      vec3 sortCol = mix(c1, c2, H(vec2(sortY, 404.0)));
      sortCol = mix(sortCol, c3, abs(stretchX));
      
      float sortFade = 1.0 - abs(stretchX);
      col = mix(col, sortCol * 0.8, sortFade * 0.6 * hSortAmt);
    }
  }
  
  // === SHARP DATA BLOCKS ===
  for(int db = 0; db < 5; db++) {
    if(float(db) >= dataBlocks) break;
    float fdb = float(db);
    float bs = blockSeeds[db];
    
    // Use hash function for better randomization
    float r1 = H(vec2(bs, 1.0));
    float r2 = H(vec2(bs, 2.0));
    float r3 = H(vec2(bs, 3.0));
    float r4 = H(vec2(bs, 4.0));
    float r5 = H(vec2(bs, 5.0));
    float r6 = H(vec2(bs, 6.0));
    float r7 = H(vec2(bs, 7.0));
    float r8 = H(vec2(bs, 8.0));
    
    // Fully random position across canvas
    vec2 blockPos = vec2(
      (r1 - 0.5) * 2.4,
      (r2 - 0.5) * 2.4
    );
    
    // Wildly varied sizes
    float widthRand = r3;
    float heightRand = r4;
    vec2 blockSize = vec2(
      0.03 + widthRand * widthRand * 0.4,  // squared for more variation
      0.03 + heightRand * heightRand * 0.35
    );
    
    // Random rotation
    float blockRot = (r5 - 0.5) * 1.2;
    vec2 bp = p - blockPos;
    float cbr = cos(blockRot); float sbr = sin(blockRot);
    bp = vec2(bp.x * cbr - bp.y * sbr, bp.x * sbr + bp.y * cbr);
    
    // Check if inside block
    vec2 blockDist = abs(bp) - blockSize;
    if(blockDist.x < 0.0 && blockDist.y < 0.0) {
      // Random color from palette - fully random selection
      vec3 blockCol;
      float colSel = r6;
      if(colSel < 0.25) {
        blockCol = c1;
      } else if(colSel < 0.5) {
        blockCol = c2;
      } else if(colSel < 0.75) {
        blockCol = c3;
      } else {
        blockCol = c4;
      }
      
      // Random brightness variation
      blockCol *= 0.6 + r7 * 0.6;
      
      // Random effect type
      float effectType = r8;
      if(effectType < 0.4) {
        // Solid color
        col = blockCol;
      } else if(effectType < 0.6) {
        // Color blend with existing
        col = mix(col, blockCol, 0.8);
      } else if(effectType < 0.8) {
        // Inverted
        col = vec3(1.0) - col;
        col = mix(col, blockCol, 0.4);
      } else {
        // Shifted
        col = col.gbr;
        col = mix(col, blockCol, 0.5);
      }
      
      // Block edge outline with random color
      float edgeDist = min(abs(blockDist.x + blockSize.x), abs(blockDist.y + blockSize.y));
      if(edgeDist < pxSize * 2.5) {
        col = r6 < 0.5 ? c1 : c2;
      }
    }
  }
  
  // === RADIAL CHROMATIC ABERRATION ===
  if(chromaAmt > 0.02) {
    vec2 center = vec2(0.0);
    vec2 dir = p - center;
    float dist = length(dir);
    vec2 offset = normalize(dir) * dist * chromaAmt * 0.08;
    
    // Sample offset positions for RGB
    vec2 rPos = p + offset;
    vec2 bPos = p - offset;
    
    // Create chromatic fringe based on position
    float rFringe = H(floor(rPos * 30.0 + vec2(t * 2.0, 0.0)));
    float bFringe = H(floor(bPos * 30.0 - vec2(t * 2.0, 0.0)));
    
    col.r = mix(col.r, c1.r * rFringe, dist * chromaAmt * 0.5);
    col.b = mix(col.b, c2.b * bFringe, dist * chromaAmt * 0.5);
  }
  
  // === CRT SCANLINES ===
  if(crtAmt > 0.02) {
    float scanline = sin(puv.y * res.y * 1.5) * 0.5 + 0.5;
    scanline = pow(scanline, 1.5);
    col *= 1.0 - scanline * crtAmt * 0.4;
    
    // CRT RGB subpixels
    float subpixel = mod(floor(puv.x * res.x), 3.0);
    if(subpixel < 1.0) col.gb *= 1.0 - crtAmt * 0.15;
    else if(subpixel < 2.0) col.rb *= 1.0 - crtAmt * 0.15;
    else col.rg *= 1.0 - crtAmt * 0.15;
    
    // CRT curve vignette
    vec2 crtUV = puv * 2.0 - 1.0;
    float crtVig = 1.0 - dot(crtUV * crtUV, crtUV * crtUV) * crtAmt * 0.3;
    col *= crtVig;
  }
  
  // === EDGE GLOW ===
  if(edgeGlow > 0.02) {
    float lum = dot(col, vec3(0.299, 0.587, 0.114));
    float glow = smoothstep(0.2, 0.6, lum);
    vec3 glowCol = mix(c1, c2, glow);
    col += glowCol * glow * edgeGlow * 0.5;
  }
  
  // === POSTERIZE ===
  if(posterize > 1.0) {
    col = floor(col * posterize + 0.5) / posterize;
  }
  
  // === INVERT ===
  if(invertAmt > 0.02) {
    col = mix(col, vec3(1.0) - col, invertAmt);
  }
  
  // === EXTRA GRAIN/DITHER ===
  float grain = H(pxCoord + floor(t * 30.0)) * 2.0 - 1.0;
  col += grain * grainAmt;
  
  // === SUBTLE VIGNETTE ===
  float vig = 1.0 - pow(length(uv - 0.5) * 1.3, 3.0) * 0.5;
  col *= vig;
  
  // === QUANTIZE COLORS (more pixelated feel) ===
  col = floor(col * 8.0 + 0.5) / 8.0;
  
  // Apply brightness
  col *= brightness;
  
  // === VARIANT A: HEAVY INTERLACED SCANLINES + COLOR BLEED ===
  float scanFreq = 200.0;
  float scanPhase = puv.y * scanFreq;
  
  // Strong scanline darkening
  float scanLine = sin(scanPhase * 3.14159);
  float scanMask = smoothstep(-0.2, 0.5, scanLine);
  col *= 0.5 + scanMask * 0.6;
  
  // Color bleeding between lines - offset each channel vertically
  float bleedAmt = 0.003;
  float lineIdx = floor(scanPhase);
  float bleedR = H(vec2(lineIdx, 1.0)) * bleedAmt;
  float bleedB = H(vec2(lineIdx, 2.0)) * bleedAmt;
  col.r *= 1.0 + sin((puv.y + bleedR) * scanFreq * 3.14159) * 0.15;
  col.b *= 1.0 + sin((puv.y - bleedB) * scanFreq * 3.14159) * 0.15;
  
  // Occasional bright interference lines
  float interference = step(0.97, H(vec2(lineIdx, floor(t * 2.0))));
  col += interference * vec3(0.3, 0.35, 0.4);
  
  // Horizontal banding noise
  float bandNoise = H(vec2(floor(puv.y * 80.0), floor(t * 0.5))) * 0.08;
  col += bandNoise;
  
  col = clamp(col, 0.0, 1.0);
  
  gl_FragColor = vec4(col, 1.0);
}
`;

const vs = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vs, VS); gl.compileShader(vs);
const fs = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fs, FS); gl.compileShader(fs);
if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(fs));

const prog = gl.createProgram();
gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);

const pLoc = gl.getAttribLocation(prog, 'p');
const U = n => gl.getUniformLocation(prog, n);
const unis = {t:U('t'),res:U('res'),h1:U('h1'),h2:U('h2'),h3:U('h3'),
  clusters:U('clusters'),density:U('density'),pixelSize:U('pixelSize'),
  scatter:U('scatter'),glitchAmt:U('glitchAmt'),rectGlitch:U('rectGlitch'),
  diagStreak:U('diagStreak'),sent:U('sent'),vol:U('vol'),
  spireCount:U('spireCount'),spireIntensity:U('spireIntensity'),
  gridIntensity:U('gridIntensity'),horizonGlow:U('horizonGlow'),bandGlitch:U('bandGlitch'),
  spireSeeds:U('spireSeeds'),dripIntensity:U('dripIntensity'),rippleAmt:U('rippleAmt'),
  auroraAmt:U('auroraAmt'),grainAmt:U('grainAmt'),chromaAmt:U('chromaAmt'),
  hSortAmt:U('hSortAmt'),marbleAmt:U('marbleAmt'),mirrorAmt:U('mirrorAmt'),
  dataBlocks:U('dataBlocks'),blockSeeds:U('blockSeeds'),crtAmt:U('crtAmt'),
  vhsAmt:U('vhsAmt'),posterize:U('posterize'),geoShapes:U('geoShapes'),
  edgeGlow:U('edgeGlow'),noiseWarp:U('noiseWarp'),invertAmt:U('invertAmt'),
  shapeSeeds:U('shapeSeeds'),isoCubes:U('isoCubes'),isoSize:U('isoSize'),
  isoRgbSplit:U('isoRgbSplit'),cubeSeeds:U('cubeSeeds'),primSeeds:U('primSeeds'),zoneOffsetX:U('zoneOffsetX'),
  zoneOffsetY:U('zoneOffsetY'),bgGradientAngle:U('bgGradientAngle'),bgNoiseScale:U('bgNoiseScale'),
  colorIntensity:U('colorIntensity'),brightness:U('brightness'),bgType:U('bgType')};

canvas.width = 1000; canvas.height = 1000;
gl.viewport(0, 0, 1000, 1000);

function render(time) {
  time *= 0.005; // 5x faster for seizure-like glitch
  gl.useProgram(prog);
  gl.enableVertexAttribArray(pLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1f(unis.t, time);
  gl.uniform2f(unis.res, 1000, 1000);
  gl.uniform1f(unis.h1, C.h1);
  gl.uniform1f(unis.h2, C.h2);
  gl.uniform1f(unis.h3, C.h3);
  gl.uniform1f(unis.clusters, C.clusters);
  gl.uniform1f(unis.density, C.density);
  gl.uniform1f(unis.pixelSize, C.pixelSize);
  gl.uniform1f(unis.scatter, C.scatter);
  gl.uniform1f(unis.glitchAmt, C.glitchAmt);
  gl.uniform1f(unis.rectGlitch, C.rectGlitch);
  gl.uniform1f(unis.diagStreak, C.diagStreak);
  gl.uniform1f(unis.sent, M.sent);
  gl.uniform1f(unis.vol, M.vol);
  gl.uniform1f(unis.spireCount, C.spireCount);
  gl.uniform1f(unis.spireIntensity, C.spireIntensity);
  gl.uniform1f(unis.gridIntensity, C.gridIntensity);
  gl.uniform1f(unis.horizonGlow, C.horizonGlow);
  gl.uniform1f(unis.bandGlitch, C.bandGlitch);
  gl.uniform1fv(unis.spireSeeds, C.spireSeeds);
  gl.uniform1f(unis.dripIntensity, C.dripIntensity);
  gl.uniform1f(unis.rippleAmt, C.rippleAmt);
  gl.uniform1f(unis.auroraAmt, C.auroraAmt);
  gl.uniform1f(unis.grainAmt, C.grainAmt);
  gl.uniform1f(unis.chromaAmt, C.chromaAmt);
  gl.uniform1f(unis.hSortAmt, C.hSortAmt);
  gl.uniform1f(unis.marbleAmt, C.marbleAmt);
  gl.uniform1f(unis.mirrorAmt, C.mirrorAmt);
  gl.uniform1f(unis.dataBlocks, C.dataBlocks);
  gl.uniform1fv(unis.blockSeeds, C.blockSeeds);
  gl.uniform1f(unis.crtAmt, C.crtAmt);
  gl.uniform1f(unis.vhsAmt, C.vhsAmt);
  gl.uniform1f(unis.posterize, C.posterize);
  gl.uniform1f(unis.geoShapes, C.geoShapes);
  gl.uniform1f(unis.edgeGlow, C.edgeGlow);
  gl.uniform1f(unis.noiseWarp, C.noiseWarp);
  gl.uniform1f(unis.invertAmt, C.invertAmt);
  gl.uniform1fv(unis.shapeSeeds, C.shapeSeeds);
  gl.uniform1f(unis.isoCubes, C.isoCubes);
  gl.uniform1f(unis.isoSize, C.isoSize);
  gl.uniform1f(unis.isoRgbSplit, C.isoRgbSplit);
  gl.uniform1fv(unis.cubeSeeds, C.cubeSeeds);
  gl.uniform1fv(unis.primSeeds, C.primSeeds);
  gl.uniform1f(unis.zoneOffsetX, C.zoneOffsetX);
  gl.uniform1f(unis.zoneOffsetY, C.zoneOffsetY);
  gl.uniform1f(unis.bgGradientAngle, C.bgGradientAngle);
  gl.uniform1f(unis.bgNoiseScale, C.bgNoiseScale);
  gl.uniform1f(unis.colorIntensity, C.colorIntensity);
  gl.uniform1f(unis.brightness, C.brightness);
  gl.uniform1i(unis.bgType, C.bgType === 'gradient' ? 1 : (C.bgType === 'textured' ? 2 : 0));
  
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
render(0);

document.getElementById('randomize').onclick = () => { gen(Math.floor(Math.random() * 100000)); history.replaceState({}, '', '?seed=' + seed); };
document.getElementById('save').onclick = () => { const a = document.createElement('a'); a.download = 'vector-dream-' + seed + '.png'; a.href = canvas.toDataURL('image/png'); a.click(); };
document.onkeydown = e => { if(e.code === 'Space') { e.preventDefault(); document.getElementById('randomize').click(); }};
</script>
</body>
</html>
