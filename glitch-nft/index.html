<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>VΞCTOR DRΞΛM</title>
  <style>
    * { margin: 0; padding: 0; }
    body { background: #000; overflow: hidden; font-family: monospace; display: flex; align-items: center; justify-content: center; min-height: 100vh; }
    canvas { display: block; width: 1200px; height: 1200px; max-width: 95vmin; max-height: 95vmin; image-rendering: pixelated; }
    #ui {
      position: fixed; bottom: 15px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 12px; align-items: center; z-index: 100;
      background: rgba(0,0,0,0.9); padding: 10px 20px; border: 1px solid #f0f3;
    }
    #ui button { background: transparent; border: 1px solid #0ff; color: #0ff; padding: 6px 14px; font: 10px monospace; cursor: pointer; }
    #ui button:hover { background: #0ff1; }
    .info { color: #f0f8; font-size: 9px; }
    #hud { position: fixed; top: 15px; right: 15px; font-size: 9px; text-align: right; z-index: 100; color: #fff4; }
    #hud .up { color: #0ff; } #hud .down { color: #f0f; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud"><div>BTC <span id="btc" class="up">---</span></div><div>ETH <span id="eth" class="up">---</span></div></div>
<div id="ui"><div class="info">#<span id="seed-num">0</span></div><button id="randomize">GENERATE</button><button id="save">CAPTURE</button></div>

<script>
let M = { sent: 0, vol: 0.3 };
async function fetchM() {
  try {
    const r = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd&include_24hr_change=true');
    const d = await r.json();
    M.btc = d.bitcoin.usd_24h_change || 0; M.eth = d.ethereum.usd_24h_change || 0;
    M.sent = Math.tanh((M.btc + M.eth) / 8);
    M.vol = Math.min(1, (Math.abs(M.btc) + Math.abs(M.eth)) / 12);
    document.getElementById('btc').textContent = (M.btc >= 0 ? '+' : '') + M.btc.toFixed(1) + '%';
    document.getElementById('btc').className = M.btc >= 0 ? 'up' : 'down';
    document.getElementById('eth').textContent = (M.eth >= 0 ? '+' : '') + M.eth.toFixed(1) + '%';
    document.getElementById('eth').className = M.eth >= 0 ? 'up' : 'down';
  } catch(e) {}
}
fetchM(); setInterval(fetchM, 45000);

let seed = parseInt(new URLSearchParams(window.location.search).get('seed')) || Math.floor(Math.random() * 100000);
function mulberry32(a) { return function() { let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }

let R, C;
function gen(s) {
  seed = s; R = mulberry32(seed);
  
  // === STYLE ARCHETYPE (each seed picks 1 of 11 distinct styles) ===
  const styleRoll = R();
  let style;
  if (styleRoll < 0.09) style = 'synthwave';
  else if (styleRoll < 0.18) style = 'databend';
  else if (styleRoll < 0.27) style = 'corrupt';
  else if (styleRoll < 0.36) style = 'liquid';
  else if (styleRoll < 0.45) style = 'minimal';
  else if (styleRoll < 0.54) style = 'retro';
  else if (styleRoll < 0.63) style = 'neon';
  else if (styleRoll < 0.72) style = 'geometric';
  else if (styleRoll < 0.81) style = 'void';
  else if (styleRoll < 0.91) style = 'isometric';
  else style = 'chaos';
  
  // === SUB-STYLE VARIANT (A, B, or C within each style) ===
  const subStyle = R() < 0.33 ? 'A' : (R() < 0.66 ? 'B' : 'C');
  
  // === COMPOSITION ZONE (where elements concentrate) ===
  const zoneRoll = R();
  let zone;
  if (zoneRoll < 0.15) zone = 'top';
  else if (zoneRoll < 0.30) zone = 'bottom';
  else if (zoneRoll < 0.45) zone = 'left';
  else if (zoneRoll < 0.60) zone = 'right';
  else if (zoneRoll < 0.75) zone = 'center';
  else if (zoneRoll < 0.88) zone = 'edges';
  else zone = 'scattered';
  
  // === BACKGROUND TYPE ===
  const bgRoll = R();
  let bgType;
  if (bgRoll < 0.4) bgType = 'solid';
  else if (bgRoll < 0.7) bgType = 'gradient';
  else bgType = 'textured';
  
  // === EXPANDED COLOR PALETTES (16 options) ===
  const pals = [
    [330, 185, 0],     // pink/cyan/red
    [320, 190, 30],    // magenta/teal/orange
    [340, 175, 200],   // coral/aqua/purple
    [310, 195, 15],    // fuchsia/mint/gold
    [350, 170, 280],   // rose/turquoise/violet
    [20, 180, 300],    // orange/cyan/magenta
    [280, 200, 40],    // purple/teal/yellow
    [345, 160, 220],   // red/blue/lavender
    [190, 330, 60],    // cyan/pink/yellow
    [260, 30, 170],    // blue/orange/magenta
    [15, 195, 315],    // red-orange/teal/purple
    [300, 180, 90],    // magenta/cyan/lime
    [45, 200, 330],    // gold/cyan/violet
    [270, 90, 180],    // purple/yellow-green/magenta
    [0, 210, 60],      // red/cyan-blue/yellow
    [225, 45, 135],    // blue/orange/pink
  ];
  const pal = pals[Math.floor(R() * pals.length)];
  
  // === COLOR INTENSITY (varies dramatically) ===
  const colorIntensity = 0.5 + R() * 0.5; // 0.5 to 1.0
  const colorShift = (R() - 0.5) * 80;    // -40 to +40 hue shift
  
  // === BRIGHTNESS/CONTRAST ===
  const brightness = 0.7 + R() * 0.6;     // 0.7 to 1.3
  
  // === BASE CONFIG (all zeroed - styles add their own) ===
  C = {
    style: style,
    subStyle: subStyle,
    zone: zone,
    bgType: bgType,
    brightness: brightness,
    // Colors with more variation
    h1: pal[0] + colorShift + (R()-.5)*70,
    h2: pal[1] + colorShift + (R()-.5)*70,
    h3: pal[2] + colorShift + (R()-.5)*80,
    colorIntensity: colorIntensity,
    // All effects start at 0
    clusters: 0, density: 0, pixelSize: 3, scatter: 0,
    glitchAmt: 0, rectGlitch: 0, diagStreak: 0,
    spireCount: 0, spireIntensity: 0, gridIntensity: 0, horizonGlow: 0, bandGlitch: 0,
    spireSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    dripIntensity: 0, rippleAmt: 0, auroraAmt: 0, grainAmt: 0,
    chromaAmt: 0, hSortAmt: 0, marbleAmt: 0, mirrorAmt: 0, dataBlocks: 0,
    blockSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    crtAmt: 0, vhsAmt: 0, posterize: 0, geoShapes: 0, edgeGlow: 0, noiseWarp: 0, invertAmt: 0,
    shapeSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    isoCubes: 0, isoSize: 0.15, isoRgbSplit: 0,
    cubeSeeds: [R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000, R()*1000],
    // Composition offsets based on zone
    zoneOffsetX: 0, zoneOffsetY: 0,
    bgGradientAngle: R() * 6.28,
    bgNoiseScale: 5 + R() * 20
  };
  
  // === ZONE OFFSETS ===
  if (zone === 'top') { C.zoneOffsetY = 0.3 + R() * 0.2; }
  else if (zone === 'bottom') { C.zoneOffsetY = -0.3 - R() * 0.2; }
  else if (zone === 'left') { C.zoneOffsetX = -0.3 - R() * 0.2; }
  else if (zone === 'right') { C.zoneOffsetX = 0.3 + R() * 0.2; }
  else if (zone === 'edges') { C.zoneOffsetX = (R() < 0.5 ? -1 : 1) * (0.4 + R() * 0.2); }
  
  // === STYLE-SPECIFIC OVERRIDES (with A/B/C sub-variants) ===
  if (style === 'synthwave') {
    C.grainAmt = 0.02 + R() * 0.04;
    if (subStyle === 'A') { // Heavy spires, minimal grid
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.spireCount = 5 + Math.floor(R() * 3);
      C.spireIntensity = 0.5 + R() * 0.4;
      C.gridIntensity = R() * 0.1;
      C.horizonGlow = 0.15 + R() * 0.2;
    } else if (subStyle === 'B') { // Grid focused, few spires
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.spireCount = Math.floor(R() * 2);
      C.spireIntensity = 0.2 + R() * 0.2;
      C.gridIntensity = 0.35 + R() * 0.35;
      C.horizonGlow = 0.2 + R() * 0.25;
      C.bandGlitch = 0.1 + R() * 0.15;
    } else { // Balanced with mirror
      C.pixelSize = 2 + Math.floor(R() * 3);
      C.spireCount = 3 + Math.floor(R() * 3);
      C.spireIntensity = 0.35 + R() * 0.3;
      C.gridIntensity = 0.15 + R() * 0.2;
      C.horizonGlow = 0.1 + R() * 0.15;
      C.mirrorAmt = 0.8 + R() * 0.2;
    }
  }
  else if (style === 'databend') {
    C.grainAmt = 0.06 + R() * 0.1;
    if (subStyle === 'A') { // Drip heavy
      C.pixelSize = 2;
      C.dripIntensity = 0.5 + R() * 0.4;
      C.auroraAmt = 0.1 + R() * 0.15;
      C.hSortAmt = 0.1 + R() * 0.15;
    } else if (subStyle === 'B') { // Aurora focused
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.dripIntensity = 0.1 + R() * 0.2;
      C.auroraAmt = 0.4 + R() * 0.4;
      C.hSortAmt = 0.2 + R() * 0.25;
      C.scatter = 0.15 + R() * 0.2;
    } else { // Sort-heavy with ripple
      C.pixelSize = 3;
      C.dripIntensity = 0.15 + R() * 0.2;
      C.hSortAmt = 0.4 + R() * 0.4;
      C.rippleAmt = 0.25 + R() * 0.3;
    }
  }
  else if (style === 'corrupt') {
    C.grainAmt = 0.04 + R() * 0.08;
    if (subStyle === 'A') { // Block heavy
      C.pixelSize = 4 + Math.floor(R() * 3);
      C.dataBlocks = 4 + Math.floor(R() * 4);
      C.glitchAmt = 0.3 + R() * 0.3;
      C.chromaAmt = 0.15 + R() * 0.2;
      C.clusters = 1;
      C.density = 0.2 + R() * 0.2;
    } else if (subStyle === 'B') { // Chromatic chaos
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.dataBlocks = 1 + Math.floor(R() * 2);
      C.chromaAmt = 0.4 + R() * 0.4;
      C.glitchAmt = 0.5 + R() * 0.4;
      C.rectGlitch = 0.4 + R() * 0.35;
      C.clusters = 2;
      C.density = 0.35 + R() * 0.3;
    } else { // Band glitch focus
      C.pixelSize = 3 + Math.floor(R() * 3);
      C.bandGlitch = 0.4 + R() * 0.4;
      C.rectGlitch = 0.35 + R() * 0.35;
      C.dataBlocks = 2 + Math.floor(R() * 2);
      C.scatter = 0.4 + R() * 0.3;
      C.clusters = 2;
      C.density = 0.3 + R() * 0.3;
    }
  }
  else if (style === 'liquid') {
    C.grainAmt = 0.02 + R() * 0.04;
    if (subStyle === 'A') { // Heavy marble
      C.pixelSize = 2;
      C.marbleAmt = 0.4 + R() * 0.35;
      C.rippleAmt = 0.1 + R() * 0.15;
      C.clusters = 1;
      C.density = 0.15 + R() * 0.2;
    } else if (subStyle === 'B') { // Ripple focused
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.marbleAmt = 0.15 + R() * 0.2;
      C.rippleAmt = 0.4 + R() * 0.35;
      C.auroraAmt = 0.2 + R() * 0.25;
      C.clusters = 2;
      C.density = 0.2 + R() * 0.25;
    } else { // Mirror liquid
      C.pixelSize = 2;
      C.marbleAmt = 0.3 + R() * 0.25;
      C.rippleAmt = 0.25 + R() * 0.25;
      C.dripIntensity = 0.2 + R() * 0.25;
      C.mirrorAmt = 0.9 + R() * 0.1;
    }
  }
  else if (style === 'minimal') {
    C.grainAmt = 0.08 + R() * 0.12;
    if (subStyle === 'A') { // Ultra sparse
      C.pixelSize = 6 + Math.floor(R() * 4);
      C.clusters = 1;
      C.density = 0.08 + R() * 0.12;
      C.scatter = 0.6 + R() * 0.3;
    } else if (subStyle === 'B') { // Streak minimal
      C.pixelSize = 4 + Math.floor(R() * 3);
      C.clusters = 1;
      C.density = 0.12 + R() * 0.15;
      C.diagStreak = 0.25 + R() * 0.3;
      C.scatter = 0.3 + R() * 0.3;
    } else { // Minimal with subtle grid
      C.pixelSize = 5 + Math.floor(R() * 3);
      C.clusters = 1;
      C.density = 0.1 + R() * 0.15;
      C.gridIntensity = 0.05 + R() * 0.08;
      C.spireCount = 1;
      C.spireIntensity = 0.1 + R() * 0.1;
    }
  }
  else if (style === 'retro') {
    if (subStyle === 'A') { // Heavy CRT
      C.pixelSize = 4 + Math.floor(R() * 3);
      C.crtAmt = 0.6 + R() * 0.35;
      C.vhsAmt = 0.1 + R() * 0.15;
      C.posterize = 6 + Math.floor(R() * 4);
      C.grainAmt = 0.06 + R() * 0.08;
      C.clusters = 2;
      C.density = 0.3 + R() * 0.25;
    } else if (subStyle === 'B') { // VHS focused
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.crtAmt = 0.2 + R() * 0.2;
      C.vhsAmt = 0.4 + R() * 0.4;
      C.posterize = 4 + Math.floor(R() * 3);
      C.grainAmt = 0.1 + R() * 0.12;
      C.bandGlitch = 0.2 + R() * 0.2;
      C.clusters = 1;
      C.density = 0.2 + R() * 0.2;
    } else { // Posterized
      C.pixelSize = 5 + Math.floor(R() * 4);
      C.crtAmt = 0.25 + R() * 0.25;
      C.posterize = 3 + Math.floor(R() * 2);
      C.grainAmt = 0.12 + R() * 0.1;
      C.chromaAmt = 0.15 + R() * 0.2;
      C.clusters = 2;
      C.density = 0.25 + R() * 0.3;
    }
  }
  else if (style === 'neon') {
    C.grainAmt = 0.01 + R() * 0.03;
    if (subStyle === 'A') { // Glow heavy
      C.pixelSize = 2;
      C.edgeGlow = 0.6 + R() * 0.35;
      C.clusters = 3 + Math.floor(R() * 2);
      C.density = 0.4 + R() * 0.35;
      C.diagStreak = 0.2 + R() * 0.2;
    } else if (subStyle === 'B') { // Streak neon
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.edgeGlow = 0.3 + R() * 0.25;
      C.diagStreak = 0.5 + R() * 0.4;
      C.clusters = 2;
      C.density = 0.3 + R() * 0.3;
      C.chromaAmt = 0.2 + R() * 0.2;
    } else { // Neon grid
      C.pixelSize = 2;
      C.edgeGlow = 0.4 + R() * 0.3;
      C.gridIntensity = 0.2 + R() * 0.25;
      C.clusters = 2;
      C.density = 0.35 + R() * 0.3;
      C.mirrorAmt = 0.7 + R() * 0.3;
    }
  }
  else if (style === 'geometric') {
    C.grainAmt = 0.01 + R() * 0.03;
    if (subStyle === 'A') { // Shape heavy
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.geoShapes = 5 + Math.floor(R() * 4);
      C.clusters = 0;
      C.density = 0.05;
      C.mirrorAmt = R() < 0.5 ? 0.9 : 0;
    } else if (subStyle === 'B') { // Iso + shapes
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.geoShapes = 2 + Math.floor(R() * 3);
      C.isoCubes = 3 + Math.floor(R() * 3);
      C.isoSize = 0.1 + R() * 0.1;
      C.isoRgbSplit = 0.01 + R() * 0.015;
    } else { // Blocks + shapes
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.geoShapes = 3 + Math.floor(R() * 3);
      C.dataBlocks = 2 + Math.floor(R() * 3);
      C.rectGlitch = 0.25 + R() * 0.25;
      C.edgeGlow = 0.2 + R() * 0.2;
    }
  }
  else if (style === 'isometric') {
    C.grainAmt = 0.015 + R() * 0.025;
    if (subStyle === 'A') { // Dense cubes
      C.pixelSize = 2;
      C.isoCubes = 6 + Math.floor(R() * 3);
      C.isoSize = 0.08 + R() * 0.08;
      C.isoRgbSplit = 0.02 + R() * 0.025;
    } else if (subStyle === 'B') { // Large cubes + grid
      C.pixelSize = 2 + Math.floor(R() * 2);
      C.isoCubes = 3 + Math.floor(R() * 2);
      C.isoSize = 0.15 + R() * 0.15;
      C.isoRgbSplit = 0.015 + R() * 0.02;
      C.gridIntensity = 0.1 + R() * 0.15;
    } else { // Cubes + geo shapes
      C.pixelSize = 2;
      C.isoCubes = 4 + Math.floor(R() * 3);
      C.isoSize = 0.1 + R() * 0.1;
      C.isoRgbSplit = 0.012 + R() * 0.018;
      C.geoShapes = 2 + Math.floor(R() * 2);
      C.mirrorAmt = R() < 0.4 ? 0.95 : 0;
    }
  }
  else if (style === 'void') {
    C.grainAmt = 0.1 + R() * 0.12;
    if (subStyle === 'A') { // Dark scatter
      C.pixelSize = 4 + Math.floor(R() * 3);
      C.clusters = 1;
      C.density = 0.06 + R() * 0.08;
      C.scatter = 0.7 + R() * 0.25;
      C.noiseWarp = 0.2 + R() * 0.2;
    } else if (subStyle === 'B') { // Inverted void
      C.pixelSize = 3 + Math.floor(R() * 3);
      C.clusters = 1;
      C.density = 0.08 + R() * 0.1;
      C.invertAmt = 0.6 + R() * 0.4;
      C.scatter = 0.5 + R() * 0.3;
      C.noiseWarp = 0.1 + R() * 0.15;
    } else { // Spire void
      C.pixelSize = 3 + Math.floor(R() * 2);
      C.spireCount = 2 + Math.floor(R() * 2);
      C.spireIntensity = 0.15 + R() * 0.15;
      C.horizonGlow = 0.08 + R() * 0.1;
      C.scatter = 0.4 + R() * 0.3;
      C.auroraAmt = 0.1 + R() * 0.15;
    }
  }
  else if (style === 'chaos') {
    // Chaos picks random elements but not all at once
    C.pixelSize = 2 + Math.floor(R() * 5);
    C.grainAmt = 0.04 + R() * 0.08;
    C.clusters = 1 + Math.floor(R() * 3);
    C.density = 0.2 + R() * 0.4;
    // Pick 3-4 random effects to activate
    const effects = ['spires','grid','drips','aurora','blocks','chromatic','marble','crt','glow','iso','shapes'];
    const shuffled = effects.sort(() => R() - 0.5);
    const picked = shuffled.slice(0, 3 + Math.floor(R() * 2));
    picked.forEach(e => {
      if (e === 'spires') { C.spireCount = 2 + Math.floor(R() * 3); C.spireIntensity = 0.2 + R() * 0.25; }
      if (e === 'grid') { C.gridIntensity = 0.15 + R() * 0.25; }
      if (e === 'drips') { C.dripIntensity = 0.25 + R() * 0.3; }
      if (e === 'aurora') { C.auroraAmt = 0.2 + R() * 0.25; }
      if (e === 'blocks') { C.dataBlocks = 2 + Math.floor(R() * 3); }
      if (e === 'chromatic') { C.chromaAmt = 0.25 + R() * 0.3; }
      if (e === 'marble') { C.marbleAmt = 0.2 + R() * 0.25; }
      if (e === 'crt') { C.crtAmt = 0.3 + R() * 0.3; }
      if (e === 'glow') { C.edgeGlow = 0.3 + R() * 0.3; }
      if (e === 'iso') { C.isoCubes = 2 + Math.floor(R() * 3); C.isoSize = 0.1 + R() * 0.1; }
      if (e === 'shapes') { C.geoShapes = 2 + Math.floor(R() * 3); }
    });
    if (R() < 0.2) C.mirrorAmt = 0.7 + R() * 0.3;
  }
  
  // === WILD CARD MUTATIONS (3-5% chance each, stacking) ===
  if (R() < 0.04) C.mirrorAmt = 1.0;
  if (R() < 0.04) C.chromaAmt += 0.35;
  if (R() < 0.04) C.pixelSize = 8 + Math.floor(R() * 5);
  if (R() < 0.04) C.grainAmt += 0.18;
  if (R() < 0.04) C.dataBlocks += 4;
  if (R() < 0.04) C.crtAmt += 0.45;
  if (R() < 0.04) C.invertAmt = 0.85 + R() * 0.15;
  if (R() < 0.04) C.edgeGlow += 0.45;
  if (R() < 0.04) C.vhsAmt += 0.35;
  if (R() < 0.04) C.posterize = 2 + Math.floor(R() * 2);
  if (R() < 0.03) { C.density = 0.85; C.scatter = 0.7; }
  if (R() < 0.03) { C.clusters = 5; C.spireCount = 7; }
  if (R() < 0.03) C.marbleAmt += 0.35;
  if (R() < 0.03) C.noiseWarp += 0.3;
  if (R() < 0.02) { C.isoCubes = 8; C.isoRgbSplit = 0.035; }
  if (R() < 0.02) { C.geoShapes = 8; }
  if (R() < 0.02) { C.h1 += 180; } // hue flip
  if (R() < 0.02) { C.colorIntensity = 0.3; } // desaturated
  if (R() < 0.02) { C.brightness = 1.4; } // blown out
  if (R() < 0.02) { C.brightness = 0.5; } // dark
  
  // Display style info
  document.getElementById('seed-num').textContent = seed + ' [' + style + '-' + subStyle + '] ' + zone;
}
gen(seed);

const canvas = document.getElementById('c');
const gl = canvas.getContext('webgl');

const VS = `attribute vec2 p;varying vec2 uv;void main(){uv=p*.5+.5;gl_Position=vec4(p,0,1);}`;

const FS = `
precision highp float;
varying vec2 uv;
uniform float t;
uniform vec2 res;
uniform float h1,h2,h3,clusters,density,pixelSize,scatter,glitchAmt,rectGlitch,diagStreak;
uniform float sent,vol;
uniform float spireCount,spireIntensity,gridIntensity,horizonGlow,bandGlitch;
uniform float spireSeeds[6];
uniform float dripIntensity,rippleAmt,auroraAmt,grainAmt;
uniform float chromaAmt,hSortAmt,marbleAmt,mirrorAmt,dataBlocks;
uniform float blockSeeds[5];
uniform float crtAmt,vhsAmt,posterize,geoShapes,edgeGlow,noiseWarp,invertAmt;
uniform float shapeSeeds[6];
uniform float isoCubes,isoSize,isoRgbSplit;
uniform float cubeSeeds[8];
uniform float zoneOffsetX,zoneOffsetY,bgGradientAngle,bgNoiseScale;
uniform float colorIntensity,brightness;
uniform int bgType; // 0=solid, 1=gradient, 2=textured

#define PI 3.14159265
#define TAU 6.28318531

float H(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
float H3(vec3 p){return fract(sin(dot(p,vec3(127.1,311.7,74.7)))*43758.5453);}

vec3 hsv(float h,float s,float v){
  vec3 c=clamp(abs(mod(h*6.+vec3(0,4,2),6.)-3.)-1.,0.,1.);
  return v*mix(vec3(1),c,s);
}

void main(){
  // Pixelate UV
  float pxSize = pixelSize / res.x;
  vec2 puv = floor(uv / pxSize) * pxSize;
  vec2 pxCoord = floor(uv * res.x / pixelSize);
  
  vec2 p = (puv - 0.5) * 2.0;
  
  // === MIRROR EFFECT (applied early to UV) ===
  if(mirrorAmt > 0.1) {
    p.x = mix(p.x, abs(p.x), mirrorAmt);
  }
  
  // === LIQUID MARBLE FLOW (UV displacement) ===
  if(marbleAmt > 0.02) {
    float flowX = sin(p.y * 4.0 + t * 0.2) * cos(p.x * 3.0 + t * 0.15);
    float flowY = cos(p.x * 5.0 - t * 0.25) * sin(p.y * 2.5 + t * 0.1);
    vec2 marble = vec2(flowX, flowY) * marbleAmt * 0.15;
    p += marble;
  }
  
  // === NOISE WARP (organic displacement) ===
  if(noiseWarp > 0.02) {
    float warpX = sin(p.x * 8.0 + p.y * 4.0 + t * 0.3) * cos(p.y * 6.0 + t * 0.2);
    float warpY = cos(p.x * 5.0 + p.y * 7.0 - t * 0.25) * sin(p.x * 4.0 + t * 0.15);
    p += vec2(warpX, warpY) * noiseWarp * 0.12;
  }
  
  // === VHS WOBBLE (horizontal distortion) ===
  if(vhsAmt > 0.02) {
    float wobble = sin(p.y * 50.0 + t * 8.0) * sin(p.y * 3.0 + t * 0.5);
    p.x += wobble * vhsAmt * 0.04;
    // VHS tracking lines
    float tracking = step(0.97, fract(p.y * 8.0 + t * 0.3));
    p.x += tracking * (H(vec2(floor(p.y * 8.0), t)) - 0.5) * 0.2 * vhsAmt;
  }
  
  // === DYNAMIC BACKGROUND ===
  vec3 col = vec3(0.01, 0.005, 0.015);
  if(bgType == 1) {
    // Gradient background
    vec2 gradDir = vec2(cos(bgGradientAngle), sin(bgGradientAngle));
    float gradT = dot(puv - 0.5, gradDir) + 0.5;
    vec3 gradCol1 = hsv(h1 / 360.0, 0.3 * colorIntensity, 0.08);
    vec3 gradCol2 = hsv(h2 / 360.0, 0.25 * colorIntensity, 0.04);
    col = mix(gradCol1, gradCol2, gradT);
  } else if(bgType == 2) {
    // Textured background
    float noise = H(floor(puv * bgNoiseScale));
    col = vec3(0.01 + noise * 0.03, 0.005 + noise * 0.02, 0.015 + noise * 0.025);
  }
  
  // Apply zone offset to working position
  vec2 zp = p - vec2(zoneOffsetX, zoneOffsetY);
  
  // === SYNTHWAVE HORIZON GRADIENT (subtle, seed-controlled) ===
  if(horizonGlow > 0.02) {
    float horizonY = -0.3 + 0.1 * sin(t * 0.05);
    if(p.y < horizonY + 0.4) {
      float gradT = smoothstep(horizonY - 0.2, horizonY + 0.4, p.y);
      vec3 deepTeal = vec3(0.02, 0.04, 0.06);
      vec3 hGlow = hsv((h1 + 20.0) / 360.0, 0.6, horizonGlow);
      col = mix(hGlow, deepTeal, gradT);
    }
  }
  
  // Colors with intensity variation
  vec3 c1 = hsv((h1 + sent * 20.0) / 360.0, 0.95 * colorIntensity, 1.0);
  vec3 c2 = hsv((h2 + sent * 15.0) / 360.0, 0.9 * colorIntensity, 1.0);
  vec3 c3 = hsv((h3 + sent * 25.0) / 360.0, 0.85 * colorIntensity, 0.9);
  vec3 c4 = hsv((h1 + 180.0) / 360.0, 0.8 * colorIntensity, 0.85);
  
  // === SYNTHWAVE CRYSTAL SPIRES (seed-controlled) ===
  float spireVis = spireIntensity + 0.1 * sent; // market influences
  for(int i = 0; i < 6; i++) {
    if(float(i) >= spireCount) break;
    float fi = float(i);
    float ss = spireSeeds[i]; // unique seed per spire
    float spireX = (H(vec2(ss, 77.0)) - 0.5) * 2.2;
    float spireWidth = 0.03 + H(vec2(ss, 78.0)) * 0.06;
    float spireHeight = 0.3 + H(vec2(ss, 79.0)) * 0.5;
    float spireBase = -0.9;
    
    // Jagged crystal shape
    float inSpire = step(abs(p.x - spireX), spireWidth * (1.0 - (p.y - spireBase) / spireHeight));
    inSpire *= step(spireBase, p.y) * step(p.y, spireBase + spireHeight);
    
    if(inSpire > 0.5) {
      // Crystal facet shading
      float facet = floor((p.y - spireBase) / 0.08);
      float shade = 0.4 + 0.3 * H(vec2(ss, facet));
      vec3 spireCol = mix(c1, c2, H(vec2(ss, 80.0))) * shade * spireVis;
      
      // Wireframe edge highlight
      float edgeDist = abs(abs(p.x - spireX) - spireWidth * (1.0 - (p.y - spireBase) / spireHeight));
      if(edgeDist < pxSize * 2.0) {
        spireCol = c1 * 0.8;
      }
      col = max(col, spireCol);
    }
  }
  
  // === HORIZON WIREFRAME GRID (seed-controlled) ===
  if(gridIntensity > 0.02) {
    float gridY = -0.5;
    if(p.y < gridY && p.y > -1.0) {
      float perspective = 1.0 / (gridY - p.y + 0.1);
      float gridX = p.x * perspective;
      float gridZ = perspective * 0.5;
      
      // Grid lines
      float lineX = smoothstep(0.02, 0.0, abs(fract(gridX * 0.8 + t * 0.1) - 0.5) - 0.45);
      float lineZ = smoothstep(0.02, 0.0, abs(fract(gridZ * 2.0 + t * 0.3) - 0.5) - 0.45);
      float grid = max(lineX, lineZ) * (gridIntensity + 0.1 * vol);
      
      vec3 gridCol = mix(c1, c2, 0.5) * grid * (1.0 - (gridY - p.y) * 0.8);
      col = max(col, gridCol);
    }
  }
  
  // === PIXEL PARTICLE CLUSTERS ===
  for(int c = 0; c < 5; c++) {
    if(float(c) >= clusters) break;
    float cf = float(c);
    
    // Cluster center (zone-adjusted)
    vec2 center = vec2(
      sin(t * 0.1 * (1.0 + cf * 0.3) + cf * 2.5) * (0.35 + cf * 0.1) + zoneOffsetX,
      cos(t * 0.08 * (1.0 + cf * 0.2) + cf * 1.8) * (0.3 + cf * 0.08) + zoneOffsetY
    );
    
    // Distance from cluster center
    float dist = length(p - center);
    
    // Cluster shape - irregular blob
    float clusterRadius = 0.35 + 0.15 * sin(t * 0.2 + cf);
    float angle = atan(p.y - center.y, p.x - center.x);
    clusterRadius += 0.1 * sin(angle * 5.0 + t + cf) + 0.05 * sin(angle * 8.0 - t * 0.5);
    
    if(dist < clusterRadius) {
      // Inside cluster - generate pixels
      float localDensity = density * (1.0 - dist / clusterRadius);
      localDensity *= 1.0 + vol * 0.3;
      
      // Random pixel on/off based on position
      float pxRand = H(pxCoord + cf * 100.0 + floor(t * 0.5));
      float pxRand2 = H(pxCoord.yx + cf * 50.0 + floor(t * 0.3));
      
      if(pxRand < localDensity) {
        // Pixel color selection
        float colChoice = H(pxCoord + cf * 200.0);
        vec3 pxCol;
        if(colChoice < 0.4) pxCol = c1;
        else if(colChoice < 0.7) pxCol = c2;
        else if(colChoice < 0.9) pxCol = c3;
        else pxCol = c4;
        
        // Slight brightness variation
        pxCol *= 0.8 + 0.4 * H(pxCoord + cf * 300.0);
        
        col = pxCol;
      }
    }
  }
  
  // === SCATTERED NOISE PIXELS ===
  float noiseRand = H(pxCoord + floor(t * 2.0));
  float noiseRand2 = H(pxCoord.yx + floor(t * 1.5));
  if(noiseRand < scatter * 0.15) {
    float colSel = H(pxCoord + 500.0);
    if(colSel < 0.5) col = c1 * (0.5 + noiseRand2);
    else col = c2 * (0.5 + noiseRand2);
  }
  
  // === DIAGONAL PIXEL STREAKS ===
  for(int i = 0; i < 8; i++) {
    float fi = float(i);
    float streakSeed = H(vec2(fi, floor(t * 0.3)));
    if(streakSeed > 1.0 - diagStreak) {
      float streakY = (H(vec2(fi, 0.0)) - 0.5) * 2.0;
      float streakX = mod(t * (0.2 + H(vec2(fi, 1.0)) * 0.3) + H(vec2(fi, 2.0)) * 5.0, 3.0) - 1.5;
      float streakAngle = -0.7 + H(vec2(fi, 3.0)) * 0.4;
      
      // Check if on streak (diagonal line of pixels)
      vec2 streakDir = vec2(cos(streakAngle), sin(streakAngle));
      vec2 toPixel = p - vec2(streakX, streakY);
      float alongStreak = dot(toPixel, streakDir);
      float perpStreak = abs(dot(toPixel, vec2(-streakDir.y, streakDir.x)));
      
      if(alongStreak > 0.0 && alongStreak < 0.4 && perpStreak < pxSize * 2.0) {
        float streakRand = H(pxCoord + fi * 100.0);
        if(streakRand < 0.7) {
          col = mix(c1, c2, H(pxCoord + fi * 150.0));
        }
      }
    }
  }
  
  // === RECTANGULAR GLITCH OUTLINES ===
  for(int i = 0; i < 6; i++) {
    float fi = float(i);
    float rectSeed = H(vec2(fi + 50.0, floor(t * 0.5)));
    if(rectSeed > 1.0 - rectGlitch) {
      vec2 rectPos = vec2(
        (H(vec2(fi, 10.0)) - 0.5) * 1.6,
        (H(vec2(fi, 11.0)) - 0.5) * 1.6
      );
      vec2 rectSize = vec2(
        0.05 + H(vec2(fi, 12.0)) * 0.2,
        0.05 + H(vec2(fi, 13.0)) * 0.15
      );
      
      // Rectangle outline check
      vec2 d = abs(p - rectPos) - rectSize;
      float outline = max(d.x, d.y);
      float innerOutline = max(d.x + pxSize * 2.0, d.y + pxSize * 2.0);
      
      if(outline < 0.0 && innerOutline > 0.0) {
        float rectColSel = H(vec2(fi, 14.0));
        if(rectColSel < 0.5) col = c1;
        else col = c3;
      }
    }
  }
  
  // === SYNTHWAVE BAND GLITCHES (chunky horizontal tears, seed-controlled) ===
  if(bandGlitch > 0.05) {
    for(int b = 0; b < 4; b++) {
      float fb = float(b);
      float bandSeed = H(vec2(fb + 20.0, floor(t * 0.2)));
      if(bandSeed > 1.0 - bandGlitch - vol * 0.1) {
        float bandY = (H(vec2(fb, 30.0)) - 0.5) * 1.8;
        float bandH = 0.02 + H(vec2(fb, 31.0)) * 0.06;
        
        if(abs(p.y - bandY) < bandH) {
          float bandShift = (H(vec2(fb, 32.0)) - 0.5) * 0.3;
          float bandRand = H(pxCoord + vec2(bandShift * 100.0, fb));
          
          // Chunky color bands like the reference
          if(bandRand < 0.5) {
            col = mix(col, c1 * 0.9, 0.7);
          } else if(bandRand < 0.7) {
            col = mix(col, c3 * 0.8, 0.5);
          }
        }
      }
    }
  }
  
  // === HORIZONTAL GLITCH DISPLACEMENT ===
  float hGlitchLine = step(0.92 - vol * 0.05, H(vec2(pxCoord.y, floor(t * 4.0))));
  if(hGlitchLine > 0.5) {
    float shiftAmt = (H(vec2(pxCoord.y + 1.0, floor(t * 4.0))) - 0.5) * 20.0;
    vec2 shiftCoord = pxCoord + vec2(shiftAmt, 0.0);
    float shiftRand = H(shiftCoord + floor(t * 2.0));
    if(shiftRand < density * 0.8) {
      col = mix(c1, c2, H(shiftCoord + 100.0));
    }
  }
  
  // === BLOCK DISPLACEMENT ===
  vec2 blockCoord = floor(uv * 8.0);
  float blockGlitch = step(0.88 - vol * 0.08, H(blockCoord + floor(t * 1.5)));
  if(blockGlitch > 0.5) {
    vec2 blockShift = (vec2(H(blockCoord + t), H(blockCoord.yx + t)) - 0.5) * 0.1;
    vec2 newPxCoord = floor((uv + blockShift) * res.x / pixelSize);
    float bRand = H(newPxCoord + 200.0);
    if(bRand < 0.5) {
      col = mix(col, c1, 0.7);
    } else if(bRand < 0.7) {
      col = mix(col, c3, 0.6);
    }
  }
  
  // === RGB CHANNEL SPLIT ===
  float rgbSplit = glitchAmt * 0.02 * (1.0 + vol);
  vec2 rCoord = floor((uv + vec2(rgbSplit, 0.0)) * res.x / pixelSize);
  vec2 bCoord = floor((uv - vec2(rgbSplit, 0.0)) * res.x / pixelSize);
  
  float rShift = H(rCoord + floor(t * 2.0));
  float bShift = H(bCoord + floor(t * 2.0));
  
  if(rShift < density * 0.5 && col.r < 0.1) col.r += c1.r * 0.6;
  if(bShift < density * 0.5 && col.b < 0.1) col.b += c2.b * 0.5;
  
  // === SCANLINE GLITCH ===
  float scanGlitch = step(0.95, sin(puv.y * 300.0 + t * 50.0));
  col = mix(col, col.gbr, scanGlitch * 0.5);
  
  // === PIXEL DROPOUT ===
  float dropout = step(0.97, H(pxCoord + floor(t * 8.0)));
  if(dropout > 0.5 && length(col) > 0.1) {
    col = vec3(0.0);
  }
  
  // === FRAME CORRUPTION BLOCKS ===
  vec2 corruptBlock = floor(uv * 5.0);
  float corrupt = step(0.93 - vol * 0.05, H(corruptBlock + floor(t * 0.8)));
  if(corrupt > 0.5) {
    col = col.brg;
  }
  
  // === STATIC NOISE BURST ===
  float staticBurst = step(0.96, H(vec2(floor(t * 6.0), 0.0)));
  if(staticBurst > 0.5) {
    float staticPx = H(pxCoord + t * 100.0);
    if(staticPx > 0.7) col = vec3(staticPx * 0.5);
  }
  
  // === AURORA COLOR CURTAINS (vertical color bleed) ===
  if(auroraAmt > 0.02) {
    for(int a = 0; a < 5; a++) {
      float fa = float(a);
      float curtainX = (H(vec2(fa, 200.0)) - 0.5) * 2.5;
      float curtainW = 0.1 + H(vec2(fa, 201.0)) * 0.3;
      float curtainDist = abs(p.x - curtainX);
      
      if(curtainDist < curtainW) {
        float curtainFade = 1.0 - curtainDist / curtainW;
        curtainFade *= curtainFade;
        
        // Vertical color gradient
        float gradPos = p.y * 0.5 + 0.5 + sin(t * 0.1 + fa) * 0.2;
        vec3 curtainCol = mix(c1, c2, gradPos);
        curtainCol = mix(curtainCol, c3, sin(gradPos * PI) * 0.5);
        
        col = mix(col, curtainCol, curtainFade * auroraAmt * 0.6);
      }
    }
  }
  
  // === VERTICAL DRIP STREAKS (pixel sort style) ===
  if(dripIntensity > 0.02) {
    float dripX = floor(puv.x * 60.0);
    float dripSeed = H(vec2(dripX, 300.0));
    
    if(dripSeed < dripIntensity) {
      float dripStart = (H(vec2(dripX, 301.0)) - 0.3) * 1.5;
      float dripLen = 0.2 + H(vec2(dripX, 302.0)) * 0.6;
      float dripSpeed = 0.1 + H(vec2(dripX, 303.0)) * 0.2;
      
      float dripY = mod(dripStart - t * dripSpeed, 2.5) - 0.5;
      
      if(p.y < dripY && p.y > dripY - dripLen) {
        float dripFade = (dripY - p.y) / dripLen;
        vec3 dripCol = mix(c1, c2, H(vec2(dripX, 304.0)));
        dripCol *= 0.7 + 0.3 * dripFade;
        col = mix(col, dripCol, (1.0 - dripFade) * 0.7);
      }
    }
  }
  
  // === RIPPLE WAVE TEXTURE ===
  if(rippleAmt > 0.02) {
    float ripple = sin(p.x * 25.0 + p.y * 8.0 + t * 0.5) * 
                   sin(p.y * 15.0 - p.x * 5.0 + t * 0.3);
    ripple = ripple * 0.5 + 0.5;
    
    // Fingerprint-like whorls
    float whorl = sin(length(p - vec2(0.3, 0.2)) * 30.0 - t * 0.2) * 
                  sin(atan(p.y - 0.2, p.x - 0.3) * 8.0 + t * 0.1);
    whorl = whorl * 0.5 + 0.5;
    
    float pattern = mix(ripple, whorl, 0.3);
    vec3 rippleCol = mix(c2, c3, pattern);
    col = mix(col, rippleCol, pattern * rippleAmt * 0.4);
  }
  
  // === HORIZONTAL PIXEL SORT STREAKS ===
  if(hSortAmt > 0.02) {
    float sortY = floor(puv.y * 40.0);
    float sortSeed = H(vec2(sortY, 400.0));
    
    if(sortSeed < hSortAmt) {
      float sortDir = H(vec2(sortY, 401.0)) < 0.5 ? 1.0 : -1.0;
      float sortSpeed = 0.2 + H(vec2(sortY, 402.0)) * 0.4;
      float sortPhase = fract(t * sortSpeed * sortDir + H(vec2(sortY, 403.0)));
      
      // Stretch colors horizontally
      float stretchX = sortPhase * 2.0 - 1.0;
      vec3 sortCol = mix(c1, c2, H(vec2(sortY, 404.0)));
      sortCol = mix(sortCol, c3, abs(stretchX));
      
      float sortFade = 1.0 - abs(stretchX);
      col = mix(col, sortCol * 0.8, sortFade * 0.6 * hSortAmt);
    }
  }
  
  // === SHARP DATA BLOCKS ===
  for(int db = 0; db < 5; db++) {
    if(float(db) >= dataBlocks) break;
    float fdb = float(db);
    float bs = blockSeeds[db];
    
    vec2 blockPos = vec2(
      (H(vec2(bs, 500.0)) - 0.5) * 1.8,
      (H(vec2(bs, 501.0)) - 0.5) * 1.8
    );
    vec2 blockSize = vec2(
      0.08 + H(vec2(bs, 502.0)) * 0.2,
      0.04 + H(vec2(bs, 503.0)) * 0.12
    );
    
    // Check if inside block
    vec2 blockDist = abs(p - blockPos) - blockSize;
    if(blockDist.x < 0.0 && blockDist.y < 0.0) {
      // Glitched block content
      float blockType = H(vec2(bs, 504.0));
      
      if(blockType < 0.3) {
        // Solid color block
        col = mix(c1, c3, H(vec2(bs, 505.0)));
      } else if(blockType < 0.6) {
        // Color-shifted version
        col = col.gbr;
      } else {
        // Inverted with color tint
        col = vec3(1.0) - col;
        col = mix(col, c2, 0.3);
      }
      
      // Block edge outline
      float edgeDist = min(abs(blockDist.x + blockSize.x), abs(blockDist.y + blockSize.y));
      if(edgeDist < pxSize * 2.5) {
        col = c1;
      }
    }
  }
  
  // === RADIAL CHROMATIC ABERRATION ===
  if(chromaAmt > 0.02) {
    vec2 center = vec2(0.0);
    vec2 dir = p - center;
    float dist = length(dir);
    vec2 offset = normalize(dir) * dist * chromaAmt * 0.08;
    
    // Sample offset positions for RGB
    vec2 rPos = p + offset;
    vec2 bPos = p - offset;
    
    // Create chromatic fringe based on position
    float rFringe = H(floor(rPos * 30.0 + vec2(t * 2.0, 0.0)));
    float bFringe = H(floor(bPos * 30.0 - vec2(t * 2.0, 0.0)));
    
    col.r = mix(col.r, c1.r * rFringe, dist * chromaAmt * 0.5);
    col.b = mix(col.b, c2.b * bFringe, dist * chromaAmt * 0.5);
  }
  
  // === GEOMETRIC SHAPES ===
  for(int gs = 0; gs < 6; gs++) {
    if(float(gs) >= geoShapes) break;
    float fgs = float(gs);
    float ss = shapeSeeds[gs];
    
    vec2 shapePos = vec2(
      (H(vec2(ss, 600.0)) - 0.5) * 1.8,
      (H(vec2(ss, 601.0)) - 0.5) * 1.8
    );
    float shapeType = H(vec2(ss, 602.0));
    float shapeSize = 0.05 + H(vec2(ss, 603.0)) * 0.15;
    
    float shapeDist;
    if(shapeType < 0.33) {
      // Circle
      shapeDist = length(p - shapePos) - shapeSize;
    } else if(shapeType < 0.66) {
      // Diamond
      vec2 d = abs(p - shapePos);
      shapeDist = (d.x + d.y) - shapeSize * 1.4;
    } else {
      // Triangle
      vec2 tp = p - shapePos;
      float k = sqrt(3.0);
      tp.x = abs(tp.x) - shapeSize;
      tp.y = tp.y + shapeSize / k;
      if(tp.x + k * tp.y > 0.0) tp = vec2(tp.x - k * tp.y, -k * tp.x - tp.y) / 2.0;
      tp.x -= clamp(tp.x, -2.0 * shapeSize, 0.0);
      shapeDist = -length(tp) * sign(tp.y);
    }
    
    // Outline only
    if(abs(shapeDist) < pxSize * 2.5) {
      vec3 shapeCol = mix(c1, c2, H(vec2(ss, 604.0)));
      col = mix(col, shapeCol, 0.8);
    }
  }
  
  // === ISOMETRIC CUBES ===
  for(int ic = 0; ic < 8; ic++) {
    if(float(ic) >= isoCubes) break;
    float fic = float(ic);
    float cs = cubeSeeds[ic];
    
    // Cube center position
    vec2 cubePos = vec2(
      (H(vec2(cs, 700.0)) - 0.5) * 1.6,
      (H(vec2(cs, 701.0)) - 0.5) * 1.6
    );
    float size = isoSize * (0.7 + H(vec2(cs, 702.0)) * 0.6);
    float cubeType = H(vec2(cs, 703.0)); // determines shape variant
    
    // Isometric angles (30 degrees = 0.866, 0.5)
    float isoX = 0.866;
    float isoY = 0.5;
    
    // Transform to isometric space
    vec2 ip = p - cubePos;
    
    // Line drawing helper - distance to line segment
    float lineW = pxSize * 2.0;
    float cubeHit = 0.0;
    vec3 cubeCol = vec3(0.8);
    
    if(cubeType < 0.5) {
      // Wireframe cube
      // Top face (hexagon-ish diamond)
      vec2 t1 = vec2(0.0, size);
      vec2 t2 = vec2(size * isoX, size * isoY);
      vec2 t3 = vec2(size * isoX, -size * isoY);
      vec2 t4 = vec2(0.0, -size);
      vec2 t5 = vec2(-size * isoX, -size * isoY);
      vec2 t6 = vec2(-size * isoX, size * isoY);
      
      // Top edges
      float d1 = abs(dot(normalize(t2 - t1), vec2(-(t2-t1).y, (t2-t1).x)) * dot(ip - t1, normalize(vec2(-(t2-t1).y, (t2-t1).x))));
      if(ip.x > min(t1.x, t2.x) - 0.01 && ip.x < max(t1.x, t2.x) + 0.01 && ip.y > min(t1.y, t2.y) - 0.01 && ip.y < max(t1.y, t2.y) + 0.01)
        if(d1 < lineW) cubeHit = 1.0;
      
      // Vertical edges
      float vEdge1 = abs(ip.x - t2.x) + abs(ip.y - (t2.y - size * 0.8));
      float vEdge2 = abs(ip.x - t6.x) + abs(ip.y - (t6.y - size * 0.8));
      float vEdge3 = abs(ip.x) + abs(ip.y - (t4.y - size * 0.4));
      
      if(abs(ip.x - t2.x) < lineW && ip.y < t2.y && ip.y > t2.y - size) cubeHit = 1.0;
      if(abs(ip.x - t6.x) < lineW && ip.y < t6.y && ip.y > t6.y - size) cubeHit = 1.0;
      if(abs(ip.x) < lineW && ip.y < t4.y && ip.y > t4.y - size * 0.6) cubeHit = 1.0;
      
      // Top diamond outline
      vec2 dp = abs(ip);
      float diamond = dp.x / (size * isoX) + dp.y / size;
      if(abs(diamond - 1.0) < lineW / size * 1.5 && ip.y > -size * isoY) cubeHit = 1.0;
      
      // Bottom edges
      if(abs(ip.y - (t2.y - size)) < lineW && ip.x > 0.0 && ip.x < t2.x + lineW) cubeHit = 1.0;
      if(abs(ip.y - (t6.y - size)) < lineW && ip.x < 0.0 && ip.x > t6.x - lineW) cubeHit = 1.0;
      
    } else if(cubeType < 0.75) {
      // Hexagon with inscribed circle
      float hexSize = size * 0.9;
      vec2 hp = abs(ip);
      float hex = max(hp.x * 0.866 + hp.y * 0.5, hp.y) - hexSize;
      if(abs(hex) < lineW) cubeHit = 1.0;
      
      // Inscribed circle
      float circle = abs(length(ip) - hexSize * 0.75);
      if(circle < lineW) cubeHit = 1.0;
      
    } else {
      // Stacked cubes (2 high)
      float smallSize = size * 0.6;
      for(int stack = 0; stack < 2; stack++) {
        vec2 stackOffset = vec2(0.0, float(stack) * smallSize * 1.2);
        vec2 sip = ip - stackOffset;
        
        // Simple cube outline
        vec2 sdp = abs(sip);
        float sDiamond = sdp.x / (smallSize * isoX) + sdp.y / smallSize;
        if(abs(sDiamond - 1.0) < lineW / smallSize * 1.5) cubeHit = 1.0;
        
        // Vertical line
        if(abs(sip.x) < lineW && sip.y < -smallSize * 0.3 && sip.y > -smallSize * 1.1) cubeHit = 1.0;
      }
    }
    
    // Apply with RGB split (anaglyph effect)
    if(cubeHit > 0.5) {
      if(isoRgbSplit > 0.001) {
        // Check offset positions for RGB
        vec2 ipR = (p + vec2(isoRgbSplit, 0.0)) - cubePos;
        vec2 ipB = (p - vec2(isoRgbSplit, 0.0)) - cubePos;
        col.r = max(col.r, 0.9);
        col.g = max(col.g, 0.85);
        col.b = max(col.b, 0.9);
      } else {
        col = mix(col, mix(c1, vec3(0.9), 0.3), 0.85);
      }
    }
    // RGB offset layers
    if(isoRgbSplit > 0.001) {
      vec2 ipR = (p + vec2(isoRgbSplit * 2.0, 0.0)) - cubePos;
      vec2 ipB = (p - vec2(isoRgbSplit * 2.0, 0.0)) - cubePos;
      vec2 dpR = abs(ipR);
      vec2 dpB = abs(ipB);
      float diaR = dpR.x / (size * isoX) + dpR.y / size;
      float diaB = dpB.x / (size * isoX) + dpB.y / size;
      if(abs(diaR - 1.0) < lineW / size * 1.5 && ipR.y > -size * isoY) col.r = max(col.r, 0.8);
      if(abs(diaB - 1.0) < lineW / size * 1.5 && ipB.y > -size * isoY) col.b = max(col.b, 0.8);
    }
  }
  
  // === CRT SCANLINES ===
  if(crtAmt > 0.02) {
    float scanline = sin(puv.y * res.y * 1.5) * 0.5 + 0.5;
    scanline = pow(scanline, 1.5);
    col *= 1.0 - scanline * crtAmt * 0.4;
    
    // CRT RGB subpixels
    float subpixel = mod(floor(puv.x * res.x), 3.0);
    if(subpixel < 1.0) col.gb *= 1.0 - crtAmt * 0.15;
    else if(subpixel < 2.0) col.rb *= 1.0 - crtAmt * 0.15;
    else col.rg *= 1.0 - crtAmt * 0.15;
    
    // CRT curve vignette
    vec2 crtUV = puv * 2.0 - 1.0;
    float crtVig = 1.0 - dot(crtUV * crtUV, crtUV * crtUV) * crtAmt * 0.3;
    col *= crtVig;
  }
  
  // === EDGE GLOW ===
  if(edgeGlow > 0.02) {
    float lum = dot(col, vec3(0.299, 0.587, 0.114));
    float glow = smoothstep(0.2, 0.6, lum);
    vec3 glowCol = mix(c1, c2, glow);
    col += glowCol * glow * edgeGlow * 0.5;
  }
  
  // === POSTERIZE ===
  if(posterize > 1.0) {
    col = floor(col * posterize + 0.5) / posterize;
  }
  
  // === INVERT ===
  if(invertAmt > 0.02) {
    col = mix(col, vec3(1.0) - col, invertAmt);
  }
  
  // === EXTRA GRAIN/DITHER ===
  float grain = H(pxCoord + floor(t * 30.0)) * 2.0 - 1.0;
  col += grain * grainAmt;
  
  // === SUBTLE VIGNETTE ===
  float vig = 1.0 - pow(length(uv - 0.5) * 1.3, 3.0) * 0.5;
  col *= vig;
  
  // === QUANTIZE COLORS (more pixelated feel) ===
  col = floor(col * 8.0 + 0.5) / 8.0;
  
  // Apply brightness
  col *= brightness;
  
  col = clamp(col, 0.0, 1.0);
  
  gl_FragColor = vec4(col, 1.0);
}
`;

const vs = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vs, VS); gl.compileShader(vs);
const fs = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fs, FS); gl.compileShader(fs);
if(!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) console.error(gl.getShaderInfoLog(fs));

const prog = gl.createProgram();
gl.attachShader(prog, vs); gl.attachShader(prog, fs); gl.linkProgram(prog);

const buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buf);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);

const pLoc = gl.getAttribLocation(prog, 'p');
const U = n => gl.getUniformLocation(prog, n);
const unis = {t:U('t'),res:U('res'),h1:U('h1'),h2:U('h2'),h3:U('h3'),
  clusters:U('clusters'),density:U('density'),pixelSize:U('pixelSize'),
  scatter:U('scatter'),glitchAmt:U('glitchAmt'),rectGlitch:U('rectGlitch'),
  diagStreak:U('diagStreak'),sent:U('sent'),vol:U('vol'),
  spireCount:U('spireCount'),spireIntensity:U('spireIntensity'),
  gridIntensity:U('gridIntensity'),horizonGlow:U('horizonGlow'),bandGlitch:U('bandGlitch'),
  spireSeeds:U('spireSeeds'),dripIntensity:U('dripIntensity'),rippleAmt:U('rippleAmt'),
  auroraAmt:U('auroraAmt'),grainAmt:U('grainAmt'),chromaAmt:U('chromaAmt'),
  hSortAmt:U('hSortAmt'),marbleAmt:U('marbleAmt'),mirrorAmt:U('mirrorAmt'),
  dataBlocks:U('dataBlocks'),blockSeeds:U('blockSeeds'),crtAmt:U('crtAmt'),
  vhsAmt:U('vhsAmt'),posterize:U('posterize'),geoShapes:U('geoShapes'),
  edgeGlow:U('edgeGlow'),noiseWarp:U('noiseWarp'),invertAmt:U('invertAmt'),
  shapeSeeds:U('shapeSeeds'),isoCubes:U('isoCubes'),isoSize:U('isoSize'),
  isoRgbSplit:U('isoRgbSplit'),cubeSeeds:U('cubeSeeds'),zoneOffsetX:U('zoneOffsetX'),
  zoneOffsetY:U('zoneOffsetY'),bgGradientAngle:U('bgGradientAngle'),bgNoiseScale:U('bgNoiseScale'),
  colorIntensity:U('colorIntensity'),brightness:U('brightness'),bgType:U('bgType')};

canvas.width = 1200; canvas.height = 1200;
gl.viewport(0, 0, 1200, 1200);

function render(time) {
  time *= 0.001;
  gl.useProgram(prog);
  gl.enableVertexAttribArray(pLoc);
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.vertexAttribPointer(pLoc, 2, gl.FLOAT, false, 0, 0);
  
  gl.uniform1f(unis.t, time);
  gl.uniform2f(unis.res, 1200, 1200);
  gl.uniform1f(unis.h1, C.h1);
  gl.uniform1f(unis.h2, C.h2);
  gl.uniform1f(unis.h3, C.h3);
  gl.uniform1f(unis.clusters, C.clusters);
  gl.uniform1f(unis.density, C.density);
  gl.uniform1f(unis.pixelSize, C.pixelSize);
  gl.uniform1f(unis.scatter, C.scatter);
  gl.uniform1f(unis.glitchAmt, C.glitchAmt);
  gl.uniform1f(unis.rectGlitch, C.rectGlitch);
  gl.uniform1f(unis.diagStreak, C.diagStreak);
  gl.uniform1f(unis.sent, M.sent);
  gl.uniform1f(unis.vol, M.vol);
  gl.uniform1f(unis.spireCount, C.spireCount);
  gl.uniform1f(unis.spireIntensity, C.spireIntensity);
  gl.uniform1f(unis.gridIntensity, C.gridIntensity);
  gl.uniform1f(unis.horizonGlow, C.horizonGlow);
  gl.uniform1f(unis.bandGlitch, C.bandGlitch);
  gl.uniform1fv(unis.spireSeeds, C.spireSeeds);
  gl.uniform1f(unis.dripIntensity, C.dripIntensity);
  gl.uniform1f(unis.rippleAmt, C.rippleAmt);
  gl.uniform1f(unis.auroraAmt, C.auroraAmt);
  gl.uniform1f(unis.grainAmt, C.grainAmt);
  gl.uniform1f(unis.chromaAmt, C.chromaAmt);
  gl.uniform1f(unis.hSortAmt, C.hSortAmt);
  gl.uniform1f(unis.marbleAmt, C.marbleAmt);
  gl.uniform1f(unis.mirrorAmt, C.mirrorAmt);
  gl.uniform1f(unis.dataBlocks, C.dataBlocks);
  gl.uniform1fv(unis.blockSeeds, C.blockSeeds);
  gl.uniform1f(unis.crtAmt, C.crtAmt);
  gl.uniform1f(unis.vhsAmt, C.vhsAmt);
  gl.uniform1f(unis.posterize, C.posterize);
  gl.uniform1f(unis.geoShapes, C.geoShapes);
  gl.uniform1f(unis.edgeGlow, C.edgeGlow);
  gl.uniform1f(unis.noiseWarp, C.noiseWarp);
  gl.uniform1f(unis.invertAmt, C.invertAmt);
  gl.uniform1fv(unis.shapeSeeds, C.shapeSeeds);
  gl.uniform1f(unis.isoCubes, C.isoCubes);
  gl.uniform1f(unis.isoSize, C.isoSize);
  gl.uniform1f(unis.isoRgbSplit, C.isoRgbSplit);
  gl.uniform1fv(unis.cubeSeeds, C.cubeSeeds);
  gl.uniform1f(unis.zoneOffsetX, C.zoneOffsetX);
  gl.uniform1f(unis.zoneOffsetY, C.zoneOffsetY);
  gl.uniform1f(unis.bgGradientAngle, C.bgGradientAngle);
  gl.uniform1f(unis.bgNoiseScale, C.bgNoiseScale);
  gl.uniform1f(unis.colorIntensity, C.colorIntensity);
  gl.uniform1f(unis.brightness, C.brightness);
  gl.uniform1i(unis.bgType, C.bgType === 'gradient' ? 1 : (C.bgType === 'textured' ? 2 : 0));
  
  gl.drawArrays(gl.TRIANGLES, 0, 6);
  requestAnimationFrame(render);
}
render(0);

document.getElementById('randomize').onclick = () => { gen(Math.floor(Math.random() * 100000)); history.replaceState({}, '', '?seed=' + seed); };
document.getElementById('save').onclick = () => { const a = document.createElement('a'); a.download = 'vector-dream-' + seed + '.png'; a.href = canvas.toDataURL('image/png'); a.click(); };
document.onkeydown = e => { if(e.code === 'Space') { e.preventDefault(); document.getElementById('randomize').click(); }};
</script>
</body>
</html>
